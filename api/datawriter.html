<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>thunderlab.datawriter API documentation</title>
<meta name="description" content="Writing numpy arrays of floats to data files â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>thunderlab.datawriter</code></h1>
</header>
<section id="section-intro">
<p>Writing numpy arrays of floats to data files.</p>
<ul>
<li><code><a title="thunderlab.datawriter.write_data" href="#thunderlab.datawriter.write_data">write_data()</a></code>: write data into a file.</li>
<li><code><a title="thunderlab.datawriter.available_formats" href="#thunderlab.datawriter.available_formats">available_formats()</a></code>: supported data and audio file formats.</li>
<li><code><a title="thunderlab.datawriter.available_encodings" href="#thunderlab.datawriter.available_encodings">available_encodings()</a></code>: encodings of a data file format.</li>
<li><code><a title="thunderlab.datawriter.format_from_extension" href="#thunderlab.datawriter.format_from_extension">format_from_extension()</a></code>: deduce data file format from file extension.</li>
<li><code><a title="thunderlab.datawriter.recode_array" href="#thunderlab.datawriter.recode_array">recode_array()</a></code>: recode array of floats.</li>
<li><code><a title="thunderlab.datawriter.insert_container_metadata" href="#thunderlab.datawriter.insert_container_metadata">insert_container_metadata()</a></code>: insert flattened metadata to data dictionary for a container file format.</li>
</ul>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="thunderlab.datawriter.data_modules"><code class="name">var <span class="ident">data_modules</span></code></dt>
<dd>
<div class="desc"><p>Dictionary with availability of various modules needed for writing data.
Keys are the module names, values are booleans.</p></div>
</dd>
<dt id="thunderlab.datawriter.data_formats_funcs"><code class="name">var <span class="ident">data_formats_funcs</span></code></dt>
<dd>
<div class="desc"><p>List of implemented formats functions.</p>
<p>Each element of the list is a tuple with the format's name, the
module's name in <code><a title="thunderlab.datawriter.data_modules" href="#thunderlab.datawriter.data_modules">data_modules</a></code> or None, and the formats function.</p></div>
</dd>
<dt id="thunderlab.datawriter.data_encodings_funcs"><code class="name">var <span class="ident">data_encodings_funcs</span></code></dt>
<dd>
<div class="desc"><p>List of implemented encodings functions.</p>
<p>Each element of the list is a tuple with the module's name and the encodings function.</p></div>
</dd>
<dt id="thunderlab.datawriter.data_writer_funcs"><code class="name">var <span class="ident">data_writer_funcs</span></code></dt>
<dd>
<div class="desc"><p>Dictionary of implemented write functions.</p>
<p>Keys are the format's name and values the corresponding write
function.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="thunderlab.datawriter.format_from_extension"><code class="name flex">
<span>def <span class="ident">format_from_extension</span></span>(<span>filepath)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_from_extension(filepath):
    &#34;&#34;&#34;Deduce data file format from file extension.

    Parameters
    ----------
    filepath: str or Path or None
        Path and name of the data file.

    Returns
    -------
    format: str
        Data format deduced from file extension.
    &#34;&#34;&#34;
    if filepath is None:
        return None
    filepath = Path(filepath)
    ext = filepath.suffix
    if not ext:
        return None
    if ext[0] == &#39;.&#39;:
        ext = ext[1:]
    if not ext:
        return None
    ext = ext.upper()
    if ext == &#39;SCANDAT&#39;:
        return &#39;RAW&#39;
    if data_modules[&#39;audioio&#39;]:
        ext = aw.format_from_extension(filepath)
    return ext</code></pre>
</details>
<div class="desc"><p>Deduce data file format from file extension.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>str</code> or <code>Path</code> or <code>None</code></dt>
<dd>Path and name of the data file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code></dt>
<dd>Data format deduced from file extension.</dd>
</dl></div>
</dd>
<dt id="thunderlab.datawriter.recode_array"><code class="name flex">
<span>def <span class="ident">recode_array</span></span>(<span>data, amax, encoding)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recode_array(data, amax, encoding):
    &#34;&#34;&#34;Recode array of floats.

    Parameters
    ----------
    data: array of floats
        Data array with values ranging between -1 and 1
    amax: float
        Maximum amplitude of data range.
    encoding: str
        Encoding, one of PCM_16, PCM_32, PCM_64, FLOAT or DOUBLE.

    Returns
    -------
    buffer: array
        The data recoded according to `encoding`.
    &#34;&#34;&#34;
    
    encodings = {&#39;PCM_16&#39;: (2, &#39;i2&#39;),
                 &#39;PCM_32&#39;: (4, &#39;i4&#39;),
                 &#39;PCM_64&#39;: (8, &#39;i8&#39;),
                 &#39;FLOAT&#39;: (4, &#39;f&#39;),
                 &#39;DOUBLE&#39;: (8, &#39;d&#39;)}

    if not encoding in encodings:
        return data
    dtype = encodings[encoding][1]
    if dtype[0] == &#39;i&#39;:
        sampwidth = encodings[encoding][0]
        factor = 2**(sampwidth*8-1)
        buffer = np.round(data/amax*factor).astype(dtype)
        buffer[data &gt;= +amax] = factor - 1
        buffer[data &lt;= -amax] = -(factor - 1)
    else:
        buffer = data.astype(dtype, copy=False)
    return buffer</code></pre>
</details>
<div class="desc"><p>Recode array of floats.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>array</code> of <code>floats</code></dt>
<dd>Data array with values ranging between -1 and 1</dd>
<dt><strong><code>amax</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum amplitude of data range.</dd>
<dt><strong><code>encoding</code></strong> :&ensp;<code>str</code></dt>
<dd>Encoding, one of PCM_16, PCM_32, PCM_64, FLOAT or DOUBLE.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>buffer</code></strong> :&ensp;<code>array</code></dt>
<dd>The data recoded according to <code>encoding</code>.</dd>
</dl></div>
</dd>
<dt id="thunderlab.datawriter.formats_relacs"><code class="name flex">
<span>def <span class="ident">formats_relacs</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def formats_relacs():
    &#34;&#34;&#34;Data format of the relacs file format.

    Returns
    -------
    formats: list of str
        List of supported file formats as strings.
    &#34;&#34;&#34;
    return [&#39;RELACS&#39;]</code></pre>
</details>
<div class="desc"><p>Data format of the relacs file format.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>formats</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of supported file formats as strings.</dd>
</dl></div>
</dd>
<dt id="thunderlab.datawriter.encodings_relacs"><code class="name flex">
<span>def <span class="ident">encodings_relacs</span></span>(<span>format=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encodings_relacs(format=None):
    &#34;&#34;&#34;Encodings of the relacs file format.

    Parameters
    ----------
    format: str
        The file format.

    Returns
    -------
    encodings: list of str
        List of supported encodings as strings.
    &#34;&#34;&#34;
    if not format:
        format = &#39;RELACS&#39;
    if format.upper() != &#39;RELACS&#39;:
        return []
    else:
        return [&#39;FLOAT&#39;]</code></pre>
</details>
<div class="desc"><p>Encodings of the relacs file format.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code></dt>
<dd>The file format.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>encodings</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of supported encodings as strings.</dd>
</dl></div>
</dd>
<dt id="thunderlab.datawriter.write_relacs"><code class="name flex">
<span>def <span class="ident">write_relacs</span></span>(<span>filepath,<br>data,<br>rate,<br>amax=1.0,<br>unit=None,<br>metadata=None,<br>locs=None,<br>labels=None,<br>format=None,<br>encoding=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_relacs(filepath, data, rate, amax=1.0, unit=None,
                 metadata=None, locs=None, labels=None, format=None,
                 encoding=None):
    &#34;&#34;&#34;Write data as relacs raw files.

    Parameters
    ----------
    filepath: str or Path
        Full path of folder where to write relacs files.
    data: 1-D or 2-D array of floats
        Array with the data (first index time, optional second index channel).
    rate: float
        Sampling rate of the data in Hertz.
    amax: float
        Maximum possible amplitude of the data in `unit`.
    unit: str
        Unit of the data.
    metadata: nested dict
        Additional metadata saved into `info.dat`.
    locs: None or 1-D or 2-D array of ints
        Marker positions (first column) and spans (optional second column)
        for each marker (rows).
    labels: None or 2-D array of string objects
        Labels (first column) and texts (optional second column)
        for each marker (rows).
    format: str or None
        File format, only None or &#39;RELACS&#39; are supported.
    encoding: str or None
        Encoding of the data. Only None or &#39;FLOAT&#39; are supported.

    Returns
    -------
    filepath: Path
        The actual folder used for writing the data.

    Raises
    ------
    ValueError
        File format or encoding not supported.
    &#34;&#34;&#34;
    if format is None:
        format = &#39;RELACS&#39;
    if format.upper() != &#39;RELACS&#39;:
        raise ValueError(f&#39;file format {format} not supported by relacs file format&#39;)
    if encoding is None:
        encoding = &#39;FLOAT&#39;
    if encoding.upper() != &#39;FLOAT&#39;:
        raise ValueError(f&#39;file encoding {encoding} not supported by relacs file format&#39;)
    filepath = Path(filepath)
    if not filepath.exists():
        filepath.mkdir()
    # write data:
    if data.ndim == 1:
        with open(filepath / f&#39;trace-1.raw&#39;, &#39;wb&#39;) as df:
            df.write(data.astype(np.float32).tobytes())
    else:
        for c in range(data.shape[1]):
            with open(filepath / f&#39;trace-{c+1}.raw&#39;, &#39;wb&#39;) as df:
                df.write(data[:, c].astype(np.float32).tobytes())
    if unit is None:
        unit = &#39;V&#39;
    # write data format:
    df = open(filepath / &#39;stimuli.dat&#39;, &#39;w&#39;)
    df.write(&#39;# analog input traces:\n&#39;)
    for c in range(data.shape[1] if data.ndim &gt; 1 else 1):
        df.write(f&#39;#     identifier{c+1}      : V-{c+1}\n&#39;)
        df.write(f&#39;#     data file{c+1}       : trace-{{c+1}}.raw\n&#39;)
        df.write(f&#39;#     sample interval{c+1} : {1000.0/rate:.4f}ms\n&#39;)
        df.write(f&#39;#     sampling rate{c+1}   : {rate:.2f}Hz\n&#39;)
        df.write(f&#39;#     unit{c+1}            : {unit}\n&#39;)
    df.write(&#39;# event lists:\n&#39;)
    df.write(&#39;#      event file1: stimulus-events.dat\n&#39;)
    df.write(&#39;#      event file2: restart-events.dat\n&#39;)
    df.write(&#39;#      event file3: recording-events.dat\n&#39;)
    df.close()
    # write empty event files:
    for events in [&#39;Recording&#39;, &#39;Restart&#39;, &#39;Stimulus&#39;]:
        df = open(filepath / f&#39;{events.lower()}-events.dat&#39;, &#39;w&#39;)
        df.write(f&#39;# events: {events}\n\n&#39;)
        df.write(&#39;#Key\n&#39;)
        if events == &#39;Stimulus&#39;:
            df.write(&#39;# t    duration\n&#39;)
            df.write(&#39;# sec  s\n&#39;)
            df.write(&#39;#   1         2\n&#39;)
        else:
            df.write(&#39;# t\n&#39;)
            df.write(&#39;# sec\n&#39;)
            df.write(&#39;# 1\n&#39;)
            if events == &#39;Recording&#39;:
                df.write(&#39;  0.0\n&#39;)
        df.close()
    # write metadata:
    if metadata:
        write_metadata_text(filepath / &#39;info.dat&#39;,
                            metadata, prefix=&#39;# &#39;)
    return filepath</code></pre>
</details>
<div class="desc"><p>Write data as relacs raw files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>str</code> or <code>Path</code></dt>
<dd>Full path of folder where to write relacs files.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>1-D</code> or <code>2-D array</code> of <code>floats</code></dt>
<dd>Array with the data (first index time, optional second index channel).</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Sampling rate of the data in Hertz.</dd>
<dt><strong><code>amax</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum possible amplitude of the data in <code>unit</code>.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>Unit of the data.</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>nested dict</code></dt>
<dd>Additional metadata saved into <code>info.dat</code>.</dd>
<dt><strong><code>locs</code></strong> :&ensp;<code>None</code> or <code>1-D</code> or <code>2-D array</code> of <code>ints</code></dt>
<dd>Marker positions (first column) and spans (optional second column)
for each marker (rows).</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>None</code> or <code>2-D array</code> of <code>string objects</code></dt>
<dd>Labels (first column) and texts (optional second column)
for each marker (rows).</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>File format, only None or 'RELACS' are supported.</dd>
<dt><strong><code>encoding</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>Encoding of the data. Only None or 'FLOAT' are supported.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>Path</code></dt>
<dd>The actual folder used for writing the data.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>File format or encoding not supported.</dd>
</dl></div>
</dd>
<dt id="thunderlab.datawriter.formats_fishgrid"><code class="name flex">
<span>def <span class="ident">formats_fishgrid</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def formats_fishgrid():
    &#34;&#34;&#34;Data format of the fishgrid file format.

    Returns
    -------
    formats: list of str
        List of supported file formats as strings.
    &#34;&#34;&#34;
    return [&#39;FISHGRID&#39;]</code></pre>
</details>
<div class="desc"><p>Data format of the fishgrid file format.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>formats</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of supported file formats as strings.</dd>
</dl></div>
</dd>
<dt id="thunderlab.datawriter.encodings_fishgrid"><code class="name flex">
<span>def <span class="ident">encodings_fishgrid</span></span>(<span>format=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encodings_fishgrid(format=None):
    &#34;&#34;&#34;Encodings of the fishgrid file format.

    Parameters
    ----------
    format: str
        The file format.

    Returns
    -------
    encodings: list of str
        List of supported encodings as strings.
    &#34;&#34;&#34;
    if not format:
        format = &#39;FISHGRID&#39;
    if format.upper() != &#39;FISHGRID&#39;:
        return []
    else:
        return [&#39;FLOAT&#39;]</code></pre>
</details>
<div class="desc"><p>Encodings of the fishgrid file format.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code></dt>
<dd>The file format.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>encodings</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of supported encodings as strings.</dd>
</dl></div>
</dd>
<dt id="thunderlab.datawriter.write_fishgrid"><code class="name flex">
<span>def <span class="ident">write_fishgrid</span></span>(<span>filepath,<br>data,<br>rate,<br>amax=1.0,<br>unit=None,<br>metadata=None,<br>locs=None,<br>labels=None,<br>format=None,<br>encoding=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_fishgrid(filepath, data, rate, amax=1.0, unit=None,
                   metadata=None, locs=None, labels=None, format=None,
                   encoding=None):
    &#34;&#34;&#34;Write data as fishgrid raw files.

    Parameters
    ----------
    filepath: str or Path
        Full path of the folder where to write fishgrid files.
    data: 1-D or 2-D array of floats
        Array with the data (first index time, optional second index channel).
    rate: float
        Sampling rate of the data in Hertz.
    amax: float
        Maximum possible amplitude of the data in `unit`.
    unit: str
        Unit of the data.
    metadata: nested dict
        Additional metadata saved into the `fishgrid.cfg`.
    locs: None or 1-D or 2-D array of ints
        Marker positions (first column) and spans (optional second column)
        for each marker (rows).
    labels: None or 2-D array of string objects
        Labels (first column) and texts (optional second column)
        for each marker (rows).
    format: str or None
        File format, only None or &#39;FISHGRID&#39; are supported.
    encoding: str or None
        Encoding of the data. Only None or &#39;FLOAT&#39; are supported.

    Returns
    -------
    filepath: Path
        The actual folder used for writing the data.

    Raises
    ------
    ValueError
        File format or encoding not supported.
    &#34;&#34;&#34;
    def write_timestamp(df, count, index, span, rate, starttime,
                        label, comment):
        datetime = starttime + dt.timedelta(seconds=index/rate)
        df.write(f&#39;    Num: {count}\n&#39;)
        df.write(f&#39; Index1: {index}\n&#39;)
        #df.write(f&#39; Index2: 0\n&#39;)
        #df.write(f&#39; Index3: 0\n&#39;)
        #df.write(f&#39; Index4: 0\n&#39;)
        if span &gt; 0:
            df.write(f&#39;  Span1: {span}\n&#39;)
        df.write(f&#39;   Date: {datetime.date().isoformat()}\n&#39;)
        df.write(f&#39;   Time: {datetime.time().isoformat(timespec=&#34;seconds&#34;)}\n&#39;)
        if label:
            df.write(f&#39;  Label: {label}\n&#39;)
        df.write(f&#39;Comment: {comment}\n&#39;)
        df.write(&#39;\n&#39;)
        
    if format is None:
        format = &#39;FISHGRID&#39;
    if format.upper() != &#39;FISHGRID&#39;:
        raise ValueError(f&#39;file format {format} not supported by fishgrid file format&#39;)
    if encoding is None:
        encoding = &#39;FLOAT&#39;
    if encoding.upper() != &#39;FLOAT&#39;:
        raise ValueError(f&#39;file encoding {encoding} not supported by fishgrid file format&#39;)
    filepath = Path(filepath)
    if not filepath.exists():
        filepath.mkdir()
    # write data:
    with open(filepath / &#39;traces-grid1.raw&#39;, &#39;wb&#39;) as df:
        df.write(data.astype(np.float32).tobytes())
    # write metadata:
    if unit is None:
        unit = &#39;mV&#39;
    cfgfile = filepath / &#39;fishgrid.cfg&#39;
    nchannels = data.shape[1] if data.ndim &gt; 1 else 1
    ncols = int(np.ceil(np.sqrt(nchannels)))
    nrows = int(np.ceil(nchannels/ncols))
    if metadata is None:
        metadata = {}
    if &#39;FishGrid&#39; in metadata:
        md = {}
        rmd = {}
        for k in metadata:
            if isinstance(metadata[k], dict):
                md[k] = deepcopy(metadata[k])
            else:
                rmd[k] = metadata[k]
        if len(rmd) &gt; 0:
            m, k = find_key(md, &#39;FishGrid.Recording&#39;)
            if k in m:
                m[k].update(rmd)
            else:
                m[k] = rmd
    else:
        smd = deepcopy(metadata)
        gm = dict(Used1=&#39;true&#39;, Columns1=f&#39;{ncols}&#39;, Rows1=f&#39;{nrows}&#39;)
        hm = {&#39;DAQ board&#39;: dict()}
        if not move_metadata(smd, hm, &#39;Amplifier&#39;):
            am = {}
            move_metadata(smd, am, [&#39;Amplifier.Name&#39;, &#39;AmplName&#39;], &#39;AmplName&#39;)
            move_metadata(smd, am, [&#39;Amplifier.Model&#39;, &#39;AmplModel&#39;], &#39;AmplModel&#39;)
            move_metadata(smd, am, &#39;Amplifier.Type&#39;)
            move_metadata(smd, am, &#39;Gain&#39;)
            move_metadata(smd, am, &#39;HighpassCutoff&#39;)
            move_metadata(smd, am, &#39;LowpassCutoff&#39;)
            if len(am) &gt; 0:
                hm[&#39;Amplifier&#39;] = am
        md = dict(FishGrid={&#39;Grid 1&#39;: gm, &#39;Hardware Settings&#39;: hm})
        move_metadata(smd, md[&#39;FishGrid&#39;], &#39;Recording&#39;)
        gm = {}
        starttime = get_datetime(smd, remove=True)
        if not starttime is None:
            gm[&#39;StartDate&#39;] = starttime.date().isoformat()
            gm[&#39;StartTime&#39;] = starttime.time().isoformat(timespec=&#39;seconds&#39;)
        move_metadata(smd, gm, &#39;Location&#39;)
        move_metadata(smd, gm, &#39;Position&#39;)
        move_metadata(smd, gm, &#39;WaterTemperature&#39;)
        move_metadata(smd, gm, &#39;WaterConductivity&#39;)
        move_metadata(smd, gm, &#39;WaterpH&#39;)
        move_metadata(smd, gm, &#39;WaterOxygen&#39;)
        move_metadata(smd, gm, &#39;Temperature&#39;)
        move_metadata(smd, gm, &#39;Humidity&#39;)
        move_metadata(smd, gm, &#39;Pressure&#39;)
        move_metadata(smd, gm, &#39;Comment&#39;)
        move_metadata(smd, gm, &#39;Experimenter&#39;)
        if len(gm) &gt; 0:
            if not &#39;Recording&#39; in md[&#39;FishGrid&#39;]:
                md[&#39;FishGrid&#39;][&#39;Recording&#39;] = {}
            md[&#39;FishGrid&#39;][&#39;Recording&#39;].update({&#39;General&#39;: gm})
        bm = {}
        move_metadata(smd, bm, &#39;DataTime&#39;)
        move_metadata(smd, bm, &#39;DataInterval&#39;)
        move_metadata(smd, bm, &#39;BufferTime&#39;)
        move_metadata(smd, bm, &#39;BufferInterval&#39;)
        if len(bm) &gt; 0:
            if not &#39;Recording&#39; in md[&#39;FishGrid&#39;]:
                md[&#39;FishGrid&#39;][&#39;Recording&#39;] = {}
            md[&#39;FishGrid&#39;][&#39;Recording&#39;].update({&#39;Buffers and timing&#39;: bm})
        if smd:
            md[&#39;FishGrid&#39;][&#39;Other&#39;] = smd
    add_metadata(md,
                 [f&#39;FishGrid.Hardware Settings.DAQ board.AISampleRate={0.001*rate:.3f}kHz&#39;,
                  f&#39;FishGrid.Hardware Settings.DAQ board.AIMaxVolt={amax:g}{unit}&#39;])
    with open(cfgfile, &#39;w&#39;) as df:
        for k in md:
            df.write(f&#39;*{k}\n&#39;)
            write_metadata_text(df, md[k], prefix=&#39;  &#39;)
    # write markers:
    filename = filepath / &#39;timestamps.dat&#39;
    starttime = get_datetime(metadata, ((&#39;DateTimeOriginal&#39;,),
                                        (&#39;OriginationDate&#39;, &#39;OriginationTime&#39;),
                                        (&#39;StartDate&#39;, &#39;StartTime&#39;),
                                        (&#39;Location_Time&#39;,)),
                             default=dt.datetime.fromtimestamp(0, dt.timezone.utc))
    with open(filename, &#39;w&#39;) as df:
        count = 0
        write_timestamp(df, count, 0, 0, rate, starttime,
                        &#39;&#39;, &#39;begin of recording&#39;)
        count += 1
        if locs is not None:
            for i in range(len(locs)):
                label = &#39;&#39;
                comment = &#39;&#39;
                if labels is not None and len(labels) &gt; i:
                    label = labels[i,0] if labels.ndim &gt; 1 else labels[i]
                    comment = labels[i,1] if labels.ndim &gt; 1 else &#39;&#39;
                index = locs[i,0] if locs.ndim &gt; 1 else locs[i]
                span = locs[i,1] if locs.ndim &gt; 1 else 0
                write_timestamp(df, count, index*nchannels,
                                span*nchannels, rate,
                                starttime, label, comment)
                count += 1
        write_timestamp(df, count, len(data)*nchannels, 0, rate,
                        starttime, &#39;&#39;, &#39;end of recording&#39;)
    return filepath</code></pre>
</details>
<div class="desc"><p>Write data as fishgrid raw files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>str</code> or <code>Path</code></dt>
<dd>Full path of the folder where to write fishgrid files.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>1-D</code> or <code>2-D array</code> of <code>floats</code></dt>
<dd>Array with the data (first index time, optional second index channel).</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Sampling rate of the data in Hertz.</dd>
<dt><strong><code>amax</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum possible amplitude of the data in <code>unit</code>.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>Unit of the data.</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>nested dict</code></dt>
<dd>Additional metadata saved into the <code>fishgrid.cfg</code>.</dd>
<dt><strong><code>locs</code></strong> :&ensp;<code>None</code> or <code>1-D</code> or <code>2-D array</code> of <code>ints</code></dt>
<dd>Marker positions (first column) and spans (optional second column)
for each marker (rows).</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>None</code> or <code>2-D array</code> of <code>string objects</code></dt>
<dd>Labels (first column) and texts (optional second column)
for each marker (rows).</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>File format, only None or 'FISHGRID' are supported.</dd>
<dt><strong><code>encoding</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>Encoding of the data. Only None or 'FLOAT' are supported.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>Path</code></dt>
<dd>The actual folder used for writing the data.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>File format or encoding not supported.</dd>
</dl></div>
</dd>
<dt id="thunderlab.datawriter.formats_pickle"><code class="name flex">
<span>def <span class="ident">formats_pickle</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def formats_pickle():
    &#34;&#34;&#34;Data formats supported by pickle.dump().

    Returns
    -------
    formats: list of str
        List of supported file formats as strings.
    &#34;&#34;&#34;
    if not data_modules[&#39;pickle&#39;]:
        return []
    else:
        return [&#39;PKL&#39;]</code></pre>
</details>
<div class="desc"><p>Data formats supported by pickle.dump().</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>formats</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of supported file formats as strings.</dd>
</dl></div>
</dd>
<dt id="thunderlab.datawriter.encodings_pickle"><code class="name flex">
<span>def <span class="ident">encodings_pickle</span></span>(<span>format=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encodings_pickle(format=None):
    &#34;&#34;&#34;Encodings of the pickle format.

    Parameters
    ----------
    format: str
        The file format.

    Returns
    -------
    encodings: list of str
        List of supported encodings as strings.
    &#34;&#34;&#34;
    if not format:
        format = &#39;PKL&#39;
    if format.upper() != &#39;PKL&#39;:
        return []
    else:
        return [&#39;PCM_16&#39;, &#39;PCM_32&#39;, &#39;FLOAT&#39;, &#39;DOUBLE&#39;]</code></pre>
</details>
<div class="desc"><p>Encodings of the pickle format.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code></dt>
<dd>The file format.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>encodings</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of supported encodings as strings.</dd>
</dl></div>
</dd>
<dt id="thunderlab.datawriter.write_pickle"><code class="name flex">
<span>def <span class="ident">write_pickle</span></span>(<span>filepath,<br>data,<br>rate,<br>amax=1.0,<br>unit=None,<br>metadata=None,<br>locs=None,<br>labels=None,<br>format=None,<br>encoding=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_pickle(filepath, data, rate, amax=1.0, unit=None,
                 metadata=None, locs=None, labels=None, format=None,
                 encoding=None):
    &#34;&#34;&#34;Write data into python pickle file.
    
    Documentation
    -------------
    https://docs.python.org/3/library/pickle.html

    Parameters
    ----------
    filepath: str or Path
        Full path and name of the file to write.
    data: 1-D or 2-D array of floats
        Array with the data (first index time, optional second index channel).
        Stored under the key &#34;data&#34;.
    rate: float
        Sampling rate of the data in Hertz.
        Stored under the key &#34;rate&#34;.
    amax: float
        Maximum possible amplitude of the data in `unit`.
        Stored under the key &#34;amax&#34;.
    unit: str
        Unit of the data.
        Stored under the key &#34;unit&#34;.
    metadata: nested dict
        Additional metadata saved into the pickle.
        Stored under the key &#34;metadata&#34;.
    locs: None or 1-D or 2-D array of ints
        Marker positions (first column) and spans (optional second column)
        for each marker (rows).
    labels: None or 2-D array of string objects
        Labels (first column) and texts (optional second column)
        for each marker (rows).
    format: str or None
        File format, only None or &#39;PKL&#39; are supported.
    encoding: str or None
        Encoding of the data.

    Returns
    -------
    filepath: Path
        The actual file name used for writing the data.

    Raises
    ------
    ImportError
        The pickle module is not available.
    ValueError
        File format or encoding not supported.
    &#34;&#34;&#34;
    if not data_modules[&#39;pickle&#39;]:
        raise ImportError
    if format is None:
        format = &#39;PKL&#39;
    if format.upper() != &#39;PKL&#39;:
        raise ValueError(f&#39;file format {format} not supported by pickle file format&#39;)
    filepath = Path(filepath)
    ext = filepath.suffix
    if len(ext) &lt;= 1 or ext[1].upper() != &#39;P&#39;:
        filepath = filepath.with_suffix(&#39;.pkl&#39;)
    if encoding is None:
        encoding = &#39;DOUBLE&#39;
    encoding = encoding.upper()
    if not encoding in encodings_pickle(format):
        raise ValueError(f&#39;file encoding {encoding} not supported by pickle file format&#39;)
    buffer = recode_array(data, amax, encoding)
    ddict = dict(data=buffer, rate=rate)
    ddict[&#39;amax&#39;] = amax
    if unit:
        ddict[&#39;unit&#39;] = unit
    if metadata:
        ddict[&#39;metadata&#39;] = metadata
    if locs is not None and len(locs) &gt; 0:
        if locs.ndim == 1:
            ddict[&#39;positions&#39;] = locs
        else:
            ddict[&#39;positions&#39;] = locs[:,0]
            if locs.shape[1] &gt; 1:
                ddict[&#39;spans&#39;] = locs[:,1]
    if labels is not None and len(labels) &gt; 0:
        if labels.ndim == 1:
            ddict[&#39;labels&#39;] = labels
        else:
            ddict[&#39;labels&#39;] = labels[:,0]
            if labels.shape[1] &gt; 1:
                ddict[&#39;descriptions&#39;] = labels[:,1]
    with open(filepath, &#39;wb&#39;) as df:
        pickle.dump(ddict, df)
    return filepath</code></pre>
</details>
<div class="desc"><p>Write data into python pickle file.</p>
<h2 id="documentation">Documentation</h2>
<p><a href="https://docs.python.org/3/library/pickle.html">https://docs.python.org/3/library/pickle.html</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>str</code> or <code>Path</code></dt>
<dd>Full path and name of the file to write.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>1-D</code> or <code>2-D array</code> of <code>floats</code></dt>
<dd>Array with the data (first index time, optional second index channel).
Stored under the key "data".</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Sampling rate of the data in Hertz.
Stored under the key "rate".</dd>
<dt><strong><code>amax</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum possible amplitude of the data in <code>unit</code>.
Stored under the key "amax".</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>Unit of the data.
Stored under the key "unit".</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>nested dict</code></dt>
<dd>Additional metadata saved into the pickle.
Stored under the key "metadata".</dd>
<dt><strong><code>locs</code></strong> :&ensp;<code>None</code> or <code>1-D</code> or <code>2-D array</code> of <code>ints</code></dt>
<dd>Marker positions (first column) and spans (optional second column)
for each marker (rows).</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>None</code> or <code>2-D array</code> of <code>string objects</code></dt>
<dd>Labels (first column) and texts (optional second column)
for each marker (rows).</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>File format, only None or 'PKL' are supported.</dd>
<dt><strong><code>encoding</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>Encoding of the data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>Path</code></dt>
<dd>The actual file name used for writing the data.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ImportError</code></dt>
<dd>The pickle module is not available.</dd>
<dt><code>ValueError</code></dt>
<dd>File format or encoding not supported.</dd>
</dl></div>
</dd>
<dt id="thunderlab.datawriter.insert_container_metadata"><code class="name flex">
<span>def <span class="ident">insert_container_metadata</span></span>(<span>metadata, data_dict, metadatakey='metadata')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_container_metadata(metadata, data_dict, metadatakey=&#39;metadata&#39;):
    &#34;&#34;&#34;Insert flattened metadata to data dictionary for a container file format.

    Parameters
    ----------
    metadata: nested dict
        Nested dictionary with key-value pairs of the meta data.
    data_dict: dict
        Dictionary of the data items contained in the container to
        which the metadata should be added.
    metadatakey: str or list of str
        Name of the variable holding the metadata.
    &#34;&#34;&#34;
    fmeta = flatten_metadata(metadata, True, sep=&#39;__&#39;)
    for k in list(fmeta):
        fmeta[metadatakey + &#39;__&#39; + k] = fmeta.pop(k)
    data_dict.update(fmeta)</code></pre>
</details>
<div class="desc"><p>Insert flattened metadata to data dictionary for a container file format.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>metadata</code></strong> :&ensp;<code>nested dict</code></dt>
<dd>Nested dictionary with key-value pairs of the meta data.</dd>
<dt><strong><code>data_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of the data items contained in the container to
which the metadata should be added.</dd>
<dt><strong><code>metadatakey</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code></dt>
<dd>Name of the variable holding the metadata.</dd>
</dl></div>
</dd>
<dt id="thunderlab.datawriter.formats_numpy"><code class="name flex">
<span>def <span class="ident">formats_numpy</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def formats_numpy():
    &#34;&#34;&#34;Data formats supported by numpy.savez().

    Returns
    -------
    formats: list of str
        List of supported file formats as strings.
    &#34;&#34;&#34;
    if not data_modules[&#39;numpy&#39;]:
        return []
    else:
        return [&#39;NPZ&#39;]</code></pre>
</details>
<div class="desc"><p>Data formats supported by numpy.savez().</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>formats</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of supported file formats as strings.</dd>
</dl></div>
</dd>
<dt id="thunderlab.datawriter.encodings_numpy"><code class="name flex">
<span>def <span class="ident">encodings_numpy</span></span>(<span>format=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encodings_numpy(format=None):
    &#34;&#34;&#34;Encodings of the numpy file format.

    Parameters
    ----------
    format: str
        The file format.

    Returns
    -------
    encodings: list of str
        List of supported encodings as strings.
    &#34;&#34;&#34;
    if not format:
        format = &#39;NPZ&#39;
    if format.upper() !=  &#39;NPZ&#39;:
        return []
    else:
        return [&#39;PCM_16&#39;, &#39;PCM_32&#39;, &#39;FLOAT&#39;, &#39;DOUBLE&#39;]</code></pre>
</details>
<div class="desc"><p>Encodings of the numpy file format.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code></dt>
<dd>The file format.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>encodings</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of supported encodings as strings.</dd>
</dl></div>
</dd>
<dt id="thunderlab.datawriter.write_numpy"><code class="name flex">
<span>def <span class="ident">write_numpy</span></span>(<span>filepath,<br>data,<br>rate,<br>amax=1.0,<br>unit=None,<br>metadata=None,<br>locs=None,<br>labels=None,<br>format=None,<br>encoding=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_numpy(filepath, data, rate, amax=1.0, unit=None,
                metadata=None, locs=None, labels=None, format=None,
                encoding=None):
    &#34;&#34;&#34;Write data into numpy npz file.
    
    Documentation
    -------------
    https://numpy.org/doc/stable/reference/generated/numpy.savez.html

    Parameters
    ----------
    filepath: str or Path
        Full path and name of the file to write.
    data: 1-D or 2-D array of floats
        Array with the data (first index time, optional second index channel).
        Stored under the key &#34;data&#34;.
    rate: float
        Sampling rate of the data in Hertz.
        Stored under the key &#34;rate&#34;.
    amax: float
        Maximum possible amplitude of the data in `unit`.
        Stored under the key &#34;amax&#34;.
    unit: str
        Unit of the data.
        Stored under the key &#34;unit&#34;.
    metadata: nested dict
        Additional metadata saved into the numpy file.
        Flattened dictionary entries stored under keys
        starting with &#34;metadata__&#34;.
    locs: None or 1-D or 2-D array of ints
        Marker positions (first column) and spans (optional second column)
        for each marker (rows).
    labels: None or 2-D array of string objects
        Labels (first column) and texts (optional second column)
        for each marker (rows).
    format: str or None
        File format, only None or &#39;NPZ&#39; are supported.
    encoding: str or None
        Encoding of the data.

    Returns
    -------
    filepath: Path
        The actual file name used for writing the data.

    Raises
    ------
    ImportError
        The numpy module is not available.
    ValueError
        File format or encoding not supported.
    &#34;&#34;&#34;
    if not data_modules[&#39;numpy&#39;]:
        raise ImportError
    if format is None:
        format = &#39;NPZ&#39;
    if format.upper() not in formats_numpy():
        raise ValueError(f&#39;file format {format} not supported by numpy file format&#39;)
    filepath = Path(filepath)
    ext = filepath.suffix
    if len(ext) &lt;= 1 or ext[1].upper() != &#39;N&#39;:
        filepath = filepath.with_suffix(&#39;.npz&#39;)
    if encoding is None:
        encoding = &#39;DOUBLE&#39;
    encoding = encoding.upper()
    if not encoding in encodings_numpy(format):
        raise ValueError(f&#39;file encoding {encoding} not supported by numpy file format&#39;)
    buffer = recode_array(data, amax, encoding)
    ddict = dict(data=buffer, rate=rate)
    ddict[&#39;amax&#39;] = amax
    if unit:
        ddict[&#39;unit&#39;] = unit
    if metadata:
        insert_container_metadata(metadata, ddict, &#39;metadata&#39;)
    if locs is not None and len(locs) &gt; 0:
        if locs.ndim == 1:
            ddict[&#39;positions&#39;] = locs
        else:
            ddict[&#39;positions&#39;] = locs[:,0]
            if locs.shape[1] &gt; 1:
                ddict[&#39;spans&#39;] = locs[:,1]
    if labels is not None and len(labels) &gt; 0:
        if labels.ndim == 1:
            maxc = np.max([len(l) for l in labels])
            ddict[&#39;labels&#39;] = labels.astype(dtype=f&#39;U{maxc}&#39;)
        else:
            maxc = np.max([len(l) for l in labels[:,0]])
            ddict[&#39;labels&#39;] = labels[:,0].astype(dtype=f&#39;U{maxc}&#39;)
            if labels.shape[1] &gt; 1:
                maxc = np.max([len(l) for l in labels[:,1]])
                ddict[&#39;descriptions&#39;] = labels[:,1].astype(dtype=f&#39;U{maxc}&#39;)
    np.savez(filepath, **ddict)
    return filepath</code></pre>
</details>
<div class="desc"><p>Write data into numpy npz file.</p>
<h2 id="documentation">Documentation</h2>
<p><a href="https://numpy.org/doc/stable/reference/generated/numpy.savez.html">https://numpy.org/doc/stable/reference/generated/numpy.savez.html</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>str</code> or <code>Path</code></dt>
<dd>Full path and name of the file to write.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>1-D</code> or <code>2-D array</code> of <code>floats</code></dt>
<dd>Array with the data (first index time, optional second index channel).
Stored under the key "data".</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Sampling rate of the data in Hertz.
Stored under the key "rate".</dd>
<dt><strong><code>amax</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum possible amplitude of the data in <code>unit</code>.
Stored under the key "amax".</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>Unit of the data.
Stored under the key "unit".</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>nested dict</code></dt>
<dd>Additional metadata saved into the numpy file.
Flattened dictionary entries stored under keys
starting with "metadata__".</dd>
<dt><strong><code>locs</code></strong> :&ensp;<code>None</code> or <code>1-D</code> or <code>2-D array</code> of <code>ints</code></dt>
<dd>Marker positions (first column) and spans (optional second column)
for each marker (rows).</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>None</code> or <code>2-D array</code> of <code>string objects</code></dt>
<dd>Labels (first column) and texts (optional second column)
for each marker (rows).</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>File format, only None or 'NPZ' are supported.</dd>
<dt><strong><code>encoding</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>Encoding of the data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>Path</code></dt>
<dd>The actual file name used for writing the data.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ImportError</code></dt>
<dd>The numpy module is not available.</dd>
<dt><code>ValueError</code></dt>
<dd>File format or encoding not supported.</dd>
</dl></div>
</dd>
<dt id="thunderlab.datawriter.formats_mat"><code class="name flex">
<span>def <span class="ident">formats_mat</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def formats_mat():
    &#34;&#34;&#34;Data formats supported by scipy.io.savemat().

    Returns
    -------
    formats: list of str
        List of supported file formats as strings.
    &#34;&#34;&#34;
    if not data_modules[&#39;scipy&#39;]:
        return []
    else:
        return [&#39;MAT&#39;]</code></pre>
</details>
<div class="desc"><p>Data formats supported by scipy.io.savemat().</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>formats</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of supported file formats as strings.</dd>
</dl></div>
</dd>
<dt id="thunderlab.datawriter.encodings_mat"><code class="name flex">
<span>def <span class="ident">encodings_mat</span></span>(<span>format=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encodings_mat(format=None):
    &#34;&#34;&#34;Encodings of the matlab format.

    Parameters
    ----------
    format: str
        The file format.

    Returns
    -------
    encodings: list of str
        List of supported encodings as strings.
    &#34;&#34;&#34;
    if not format:
        format = &#39;MAT&#39;
    if format.upper() != &#39;MAT&#39;:
        return []
    else:
        return [&#39;PCM_16&#39;, &#39;PCM_32&#39;, &#39;FLOAT&#39;, &#39;DOUBLE&#39;]</code></pre>
</details>
<div class="desc"><p>Encodings of the matlab format.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code></dt>
<dd>The file format.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>encodings</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of supported encodings as strings.</dd>
</dl></div>
</dd>
<dt id="thunderlab.datawriter.write_mat"><code class="name flex">
<span>def <span class="ident">write_mat</span></span>(<span>filepath,<br>data,<br>rate,<br>amax=1.0,<br>unit=None,<br>metadata=None,<br>locs=None,<br>labels=None,<br>format=None,<br>encoding=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_mat(filepath, data, rate, amax=1.0, unit=None,
              metadata=None, locs=None, labels=None, format=None,
              encoding=None):
    &#34;&#34;&#34;Write data into matlab file.
    
    Documentation
    -------------
    https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.savemat.html

    Parameters
    ----------
    filepath: str or Path
        Full path and name of the file to write.
    data: 1-D or 2-D array of floats
        Array with the data (first index time, optional second index channel).
        Stored under the key &#34;data&#34;.
    rate: float
        Sampling rate of the data in Hertz.
        Stored under the key &#34;rate&#34;.
    amax: float
        Maximum possible amplitude of the data in `unit`.
        Stored under the key &#34;amax&#34;.
    unit: str
        Unit of the data.
        Stored under the key &#34;unit&#34;.
    metadata: nested dict
        Additional metadata saved into the mat file.
        Stored under the key &#34;metadata&#34;.
    locs: None or 1-D or 2-D array of ints
        Marker positions (first column) and spans (optional second column)
        for each marker (rows).
    labels: None or 2-D array of string objects
        Labels (first column) and texts (optional second column)
        for each marker (rows).
    format: str or None
        File format, only None or &#39;MAT&#39; are supported.
    encoding: str or None
        Encoding of the data.

    Returns
    -------
    filepath: Path
        The actual file name used for writing the data.

    Raises
    ------
    ImportError
        The scipy.io module is not available.
    ValueError
        File format or encoding not supported.
    &#34;&#34;&#34;
    if not data_modules[&#39;scipy&#39;]:
        raise ImportError
    if format is None:
        format = &#39;MAT&#39;
    if format.upper() not in formats_mat():
        raise ValueError(f&#39;file format {format} not supported by matlab file format&#39;)
    filepath = Path(filepath)
    ext = filepath.suffix
    if len(ext) &lt;= 1 or ext[1].upper() != &#39;M&#39;:
        filepath = filepath.with_suffix(&#39;.mat&#39;)
    if encoding is None:
        encoding = &#39;DOUBLE&#39;
    encoding = encoding.upper()
    if not encoding in encodings_mat(format):
        raise ValueError(f&#39;file encoding {encoding} not supported by matlab file format&#39;)
    buffer = recode_array(data, amax, encoding)
    ddict = dict(data=buffer, rate=rate)
    ddict[&#39;amax&#39;] = amax
    if unit:
        ddict[&#39;unit&#39;] = unit
    if metadata:
        insert_container_metadata(metadata, ddict, &#39;metadata&#39;)
    if locs is not None and len(locs) &gt; 0:
        if locs.ndim == 1:
            ddict[&#39;positions&#39;] = locs
        else:
            ddict[&#39;positions&#39;] = locs[:,0]
            if locs.shape[1] &gt; 1:
                ddict[&#39;spans&#39;] = locs[:,1]
    if labels is not None and len(labels) &gt; 0:
        if labels.ndim == 1:
            maxc = np.max([len(l) for l in labels])
            ddict[&#39;labels&#39;] = labels.astype(dtype=f&#39;U{maxc}&#39;)
        else:
            maxc = np.max([len(l) for l in labels[:,0]])
            ddict[&#39;labels&#39;] = labels[:,0].astype(dtype=f&#39;U{maxc}&#39;)
            if labels.shape[1] &gt; 1:
                maxc = np.max([len(l) for l in labels[:,1]])
                ddict[&#39;descriptions&#39;] = labels[:,1].astype(dtype=f&#39;U{maxc}&#39;)
    sio.savemat(filepath, ddict)
    return filepath</code></pre>
</details>
<div class="desc"><p>Write data into matlab file.</p>
<h2 id="documentation">Documentation</h2>
<p><a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.savemat.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.savemat.html</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>str</code> or <code>Path</code></dt>
<dd>Full path and name of the file to write.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>1-D</code> or <code>2-D array</code> of <code>floats</code></dt>
<dd>Array with the data (first index time, optional second index channel).
Stored under the key "data".</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Sampling rate of the data in Hertz.
Stored under the key "rate".</dd>
<dt><strong><code>amax</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum possible amplitude of the data in <code>unit</code>.
Stored under the key "amax".</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>Unit of the data.
Stored under the key "unit".</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>nested dict</code></dt>
<dd>Additional metadata saved into the mat file.
Stored under the key "metadata".</dd>
<dt><strong><code>locs</code></strong> :&ensp;<code>None</code> or <code>1-D</code> or <code>2-D array</code> of <code>ints</code></dt>
<dd>Marker positions (first column) and spans (optional second column)
for each marker (rows).</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>None</code> or <code>2-D array</code> of <code>string objects</code></dt>
<dd>Labels (first column) and texts (optional second column)
for each marker (rows).</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>File format, only None or 'MAT' are supported.</dd>
<dt><strong><code>encoding</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>Encoding of the data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>Path</code></dt>
<dd>The actual file name used for writing the data.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ImportError</code></dt>
<dd>The scipy.io module is not available.</dd>
<dt><code>ValueError</code></dt>
<dd>File format or encoding not supported.</dd>
</dl></div>
</dd>
<dt id="thunderlab.datawriter.formats_raw"><code class="name flex">
<span>def <span class="ident">formats_raw</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def formats_raw():
    &#34;&#34;&#34;Data formats supported as raw formats.

    Returns
    -------
    formats: list of str
        List of supported file formats as strings.
    &#34;&#34;&#34;
    return [&#39;RAW&#39;]</code></pre>
</details>
<div class="desc"><p>Data formats supported as raw formats.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>formats</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of supported file formats as strings.</dd>
</dl></div>
</dd>
<dt id="thunderlab.datawriter.encodings_raw"><code class="name flex">
<span>def <span class="ident">encodings_raw</span></span>(<span>format=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encodings_raw(format=None):
    &#34;&#34;&#34;Encodings supported for raw file formats.

    Parameters
    ----------
    format: str
        The file format.

    Returns
    -------
    encodings: list of str
        List of supported encodings as strings.
    &#34;&#34;&#34;
    if not format:
        format = &#39;RAW&#39;
    if format.upper() != &#39;RAW&#39;:
        return []
    else:
        return [&#39;PCM_16&#39;, &#39;PCM_32&#39;, &#39;FLOAT&#39;, &#39;DOUBLE&#39;]</code></pre>
</details>
<div class="desc"><p>Encodings supported for raw file formats.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code></dt>
<dd>The file format.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>encodings</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of supported encodings as strings.</dd>
</dl></div>
</dd>
<dt id="thunderlab.datawriter.write_raw"><code class="name flex">
<span>def <span class="ident">write_raw</span></span>(<span>filepath,<br>data,<br>rate,<br>amax=1.0,<br>unit=None,<br>metadata=None,<br>locs=None,<br>labels=None,<br>format=None,<br>encoding=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_raw(filepath, data, rate, amax=1.0, unit=None,
              metadata=None, locs=None, labels=None, format=None,
              encoding=None):
    &#34;&#34;&#34;Write data into raw file.

    Writes just the data without sampling rate, metadata and markers.

    Parameters
    ----------
    filepath: str or Path
        Full path and name of the file to write.
    data: 1-D or 2-D array of floats
        Array with the data (first index time, optional second index channel).
    rate: float
        Sampling rate of the data in Hertz.
    amax: float
        Maximum possible amplitude of the data in `unit`.
    unit: str
        Unit of the data.
    metadata: nested dict
        Additional metadata saved into the mat file.
    locs: None or 1-D or 2-D array of ints
        Marker positions (first column) and spans (optional second column)
        for each marker (rows).
    labels: None or 2-D array of string objects
        Labels (first column) and texts (optional second column)
        for each marker (rows).
    format: str or None
        File format, only None or &#39;RAW&#39; are supported.
    encoding: str or None
        Encoding of the data.

    Returns
    -------
    filepath: Path
        The actual file name used for writing the data.

    Raises
    ------
    ValueError
        File format or encoding not supported.
    &#34;&#34;&#34;
    if format is None:
        format = &#39;RAW&#39;
    if format.upper() not in formats_raw():
        raise ValueError(f&#39;file format {format} not supported by matlab file format&#39;)
    filepath = Path(filepath)
    ext = filepath.suffix
    if len(ext) &lt;= 1 or ext[1].upper() != &#39;R&#39;:
        filepath = filepath.with_suffix(&#39;.raw&#39;)
    if encoding is None:
        encoding = &#39;DOUBLE&#39;
    encoding = encoding.upper()
    if not encoding in encodings_raw(format):
        raise ValueError(f&#39;file encoding {encoding} not supported by raw file format&#39;)
    buffer = recode_array(data, amax, encoding)
    with open(filepath, &#39;wb&#39;) as df:
        df.write(buffer.tobytes())
    return filepath</code></pre>
</details>
<div class="desc"><p>Write data into raw file.</p>
<p>Writes just the data without sampling rate, metadata and markers.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>str</code> or <code>Path</code></dt>
<dd>Full path and name of the file to write.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>1-D</code> or <code>2-D array</code> of <code>floats</code></dt>
<dd>Array with the data (first index time, optional second index channel).</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Sampling rate of the data in Hertz.</dd>
<dt><strong><code>amax</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum possible amplitude of the data in <code>unit</code>.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>Unit of the data.</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>nested dict</code></dt>
<dd>Additional metadata saved into the mat file.</dd>
<dt><strong><code>locs</code></strong> :&ensp;<code>None</code> or <code>1-D</code> or <code>2-D array</code> of <code>ints</code></dt>
<dd>Marker positions (first column) and spans (optional second column)
for each marker (rows).</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>None</code> or <code>2-D array</code> of <code>string objects</code></dt>
<dd>Labels (first column) and texts (optional second column)
for each marker (rows).</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>File format, only None or 'RAW' are supported.</dd>
<dt><strong><code>encoding</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>Encoding of the data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>Path</code></dt>
<dd>The actual file name used for writing the data.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>File format or encoding not supported.</dd>
</dl></div>
</dd>
<dt id="thunderlab.datawriter.formats_audioio"><code class="name flex">
<span>def <span class="ident">formats_audioio</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def formats_audioio():
    &#34;&#34;&#34;Data formats supported by audioio.

    Returns
    -------
    formats: list of str
        List of supported file formats as strings.
    &#34;&#34;&#34;
    if not data_modules[&#39;audioio&#39;]:
        return []
    else:
        return aw.available_formats()</code></pre>
</details>
<div class="desc"><p>Data formats supported by audioio.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>formats</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of supported file formats as strings.</dd>
</dl></div>
</dd>
<dt id="thunderlab.datawriter.encodings_audio"><code class="name flex">
<span>def <span class="ident">encodings_audio</span></span>(<span>format)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encodings_audio(format):
    &#34;&#34;&#34;Encodings of any audio format.

    Parameters
    ----------
    format: str
        The file format.

    Returns
    -------
    encodings: list of str
        List of supported encodings as strings.
    &#34;&#34;&#34;
    if not data_modules[&#39;audioio&#39;]:
        return []
    else:
        return aw.available_encodings(format)</code></pre>
</details>
<div class="desc"><p>Encodings of any audio format.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code></dt>
<dd>The file format.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>encodings</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of supported encodings as strings.</dd>
</dl></div>
</dd>
<dt id="thunderlab.datawriter.write_audioio"><code class="name flex">
<span>def <span class="ident">write_audioio</span></span>(<span>filepath,<br>data,<br>rate,<br>amax=1.0,<br>unit=None,<br>metadata=None,<br>locs=None,<br>labels=None,<br>format=None,<br>encoding=None,<br>gainkey=['AIMaxVolt', 'gain'],<br>sep='.')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_audioio(filepath, data, rate, amax=1.0, unit=None,
                  metadata=None, locs=None, labels=None, format=None,
                  encoding=None, gainkey=default_gain_keys, sep=&#39;.&#39;):
    &#34;&#34;&#34;Write data into audio file.

    If a gain setting is available in the metadata, then the data are divided
    by the gain before they are stored in the audio file.
    After this operation, the data values need to range between -1 and 1,
    in particular if the data are encoded as integers
    (i.e. PCM_16, PCM_32 and PCM_64).
    Note, that this function does not check for this requirement!
    
    Documentation
    -------------
    https://bendalab.github.io/audioio/

    Parameters
    ----------
    filepath: str or Path
        Full path and name of the file to write.
    data: 1-D or 2-D array of floats
        Array with the data (first index time, optional second index channel).
    rate: float
        Sampling rate of the data in Hertz.
    amax: float
        Maximum possible amplitude of the data in `unit`.
    unit: str
        Unit of the data. If supplied and a gain is found in the metadata it
        has to match the unit of the gain. If no gain is found in the metadata
        and metadata is not None, then a gain of one with this unit is added
        to the metadata using the first key in `gainkey`.
    metadata: nested dict
        Metadata saved into the audio file. If it contains a gain,
        the gain factor is used to divide the data down into a
        range between -1 and 1.
    locs: None or 1-D or 2-D array of ints
        Marker positions (first column) and spans (optional second column)
        for each marker (rows).
    labels: None or 2-D array of string objects
        Labels (first column) and texts (optional second column)
        for each marker (rows).
    format: str or None
        File format. If None deduce file format from filepath.
        See `available_formats()` for possible values.
    encoding: str or None
        Encoding of the data. See `available_encodings()` for possible values.
        If None or empty string use &#39;PCM_16&#39;.
    gainkey: str or list of str
        Key in the file&#39;s metadata that holds some gain information.
        If found, the data will be multiplied with the gain,
        and if available, the corresponding unit is returned.
        See the [audioio.get_gain()](https://bendalab.github.io/audioio/api/audiometadata.html#audioio.audiometadata.get_gain) function for details.
    sep: str
        String that separates section names in `gainkey`.

    Returns
    -------
    filepath: Path
        The actual file name used for writing the data.

    Raises
    ------
    ImportError
        The audioio module is not available.
    ValueError
        `unit` does not match gain in metadata.
    &#34;&#34;&#34;
    if not data_modules[&#39;audioio&#39;]:
        raise ImportError
    if amax is None or not np.isfinite(amax):
        amax, u = am.get_gain(metadata, gainkey, sep, 1.0, &#39;a.u.&#39;)
        if not unit:
            unit = u
        elif unit != &#39;a.u.&#39; and u != &#39;a.u.&#39; and unit != u:
            raise ValueError(f&#39;unit &#34;{unit}&#34; does not match gain unit &#34;{u}&#34; in metadata&#39;)
    if amax != 1.0:
        data = data / amax
        if metadata is None:
            metadata = {}
        if unit == &#39;a.u.&#39;:
            unit = &#39;&#39;
        if not isinstance(gainkey, (list, tuple, np.ndarray)):
            gainkey = [gainkey,]
        gainkey.append(&#39;Gain&#39;)
        for gk in gainkey:
            m, k = am.find_key(metadata, gk)
            if k in m:
                m[k] = f&#39;{amax:g}{unit}&#39;
                break
        else:
            if &#39;INFO&#39; in metadata:
                metadata[&#39;INFO&#39;][gainkey[0]] = f&#39;{amax:g}{unit}&#39;
            else:
                metadata[gainkey[0]] = f&#39;{amax:g}{unit}&#39;
    aw.write_audio(filepath, data, rate, metadata, locs, labels)
    return Path(filepath)</code></pre>
</details>
<div class="desc"><p>Write data into audio file.</p>
<p>If a gain setting is available in the metadata, then the data are divided
by the gain before they are stored in the audio file.
After this operation, the data values need to range between -1 and 1,
in particular if the data are encoded as integers
(i.e. PCM_16, PCM_32 and PCM_64).
Note, that this function does not check for this requirement!</p>
<h2 id="documentation">Documentation</h2>
<p><a href="https://bendalab.github.io/audioio/">https://bendalab.github.io/audioio/</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>str</code> or <code>Path</code></dt>
<dd>Full path and name of the file to write.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>1-D</code> or <code>2-D array</code> of <code>floats</code></dt>
<dd>Array with the data (first index time, optional second index channel).</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Sampling rate of the data in Hertz.</dd>
<dt><strong><code>amax</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum possible amplitude of the data in <code>unit</code>.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>Unit of the data. If supplied and a gain is found in the metadata it
has to match the unit of the gain. If no gain is found in the metadata
and metadata is not None, then a gain of one with this unit is added
to the metadata using the first key in <code>gainkey</code>.</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>nested dict</code></dt>
<dd>Metadata saved into the audio file. If it contains a gain,
the gain factor is used to divide the data down into a
range between -1 and 1.</dd>
<dt><strong><code>locs</code></strong> :&ensp;<code>None</code> or <code>1-D</code> or <code>2-D array</code> of <code>ints</code></dt>
<dd>Marker positions (first column) and spans (optional second column)
for each marker (rows).</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>None</code> or <code>2-D array</code> of <code>string objects</code></dt>
<dd>Labels (first column) and texts (optional second column)
for each marker (rows).</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>File format. If None deduce file format from filepath.
See <code><a title="thunderlab.datawriter.available_formats" href="#thunderlab.datawriter.available_formats">available_formats()</a></code> for possible values.</dd>
<dt><strong><code>encoding</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>Encoding of the data. See <code><a title="thunderlab.datawriter.available_encodings" href="#thunderlab.datawriter.available_encodings">available_encodings()</a></code> for possible values.
If None or empty string use 'PCM_16'.</dd>
<dt><strong><code>gainkey</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code></dt>
<dd>Key in the file's metadata that holds some gain information.
If found, the data will be multiplied with the gain,
and if available, the corresponding unit is returned.
See the <a href="https://bendalab.github.io/audioio/api/audiometadata.html#audioio.audiometadata.get_gain">audioio.get_gain()</a> function for details.</dd>
<dt><strong><code>sep</code></strong> :&ensp;<code>str</code></dt>
<dd>String that separates section names in <code>gainkey</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>Path</code></dt>
<dd>The actual file name used for writing the data.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ImportError</code></dt>
<dd>The audioio module is not available.</dd>
<dt><code>ValueError</code></dt>
<dd><code>unit</code> does not match gain in metadata.</dd>
</dl></div>
</dd>
<dt id="thunderlab.datawriter.available_formats"><code class="name flex">
<span>def <span class="ident">available_formats</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def available_formats():
    &#34;&#34;&#34;Data and audio file formats supported by any of the installed modules.

    Returns
    -------
    formats: list of str
        List of supported file formats as strings.
    &#34;&#34;&#34;
    formats = set()
    for fmt, lib, formats_func in data_formats_funcs:
        if not lib or data_modules[lib]:
            formats |= set(formats_func())
    return sorted(list(formats))</code></pre>
</details>
<div class="desc"><p>Data and audio file formats supported by any of the installed modules.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>formats</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of supported file formats as strings.</dd>
</dl></div>
</dd>
<dt id="thunderlab.datawriter.available_encodings"><code class="name flex">
<span>def <span class="ident">available_encodings</span></span>(<span>format)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def available_encodings(format):
    &#34;&#34;&#34;Encodings of a data file format.

    Parameters
    ----------
    format: str
        The file format.

    Returns
    -------
    encodings: list of str
        List of supported encodings as strings.
    &#34;&#34;&#34;
    for module, encodings_func in data_encodings_funcs:
        encs = encodings_func(format)
        if len(encs) &gt; 0:
            return encs
    return []</code></pre>
</details>
<div class="desc"><p>Encodings of a data file format.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code></dt>
<dd>The file format.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>encodings</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of supported encodings as strings.</dd>
</dl></div>
</dd>
<dt id="thunderlab.datawriter.write_data"><code class="name flex">
<span>def <span class="ident">write_data</span></span>(<span>filepath,<br>data,<br>rate,<br>amax=1.0,<br>unit=None,<br>metadata=None,<br>locs=None,<br>labels=None,<br>format=None,<br>encoding=None,<br>verbose=0,<br>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_data(filepath, data, rate, amax=1.0, unit=None,
               metadata=None, locs=None, labels=None, format=None,
               encoding=None, verbose=0, **kwargs):
    &#34;&#34;&#34;Write data into a file.

    Parameters
    ----------
    filepath: str or Path
        Full path and name of the file to write.
        File format is determined from extension.
    data: 1-D or 2-D array of floats
        Array with the data (first index time, second index channel).
    rate: float
        Sampling rate of the data in Hertz.
    amax: float
        Maximum possible amplitude of the data in `unit`.
    unit: str
        Unit of the data.
    metadata: nested dict
        Additional metadata.
    locs: None or 1-D or 2-D array of ints
        Marker positions (first column) and spans (optional second column)
        for each marker (rows).
    labels: None or 2-D array of string objects
        Labels (first column) and texts (optional second column)
        for each marker (rows).
    format: str or None
        File format. If None deduce file format from filepath.
        See `available_formats()` for possible values.
    encoding: str or None
        Encoding of the data. See `available_encodings()` for possible values.
        If None or empty string use &#39;PCM_16&#39;.
    verbose: int
        If &gt;0 show detailed error/warning messages.
    kwargs: dict
        Additional, file format specific keyword arguments.

    Returns
    -------
    filepath: str or None
        On success, the actual file name used for writing the data.

    Raises
    ------
    ValueError
        Unspecified file format.
    IOError
        Requested file format not supported.

    Example
    -------
    ```
    import numpy as np
    from thunderlab.datawriter import write_data
    
    rate = 28000.0
    freq = 800.0
    time = np.arange(0.0, 1.0, 1/rate)     # one second
    data = 2.5*np.sin(2.0*np.p*freq*time)        # 800Hz sine wave
    md = dict(Artist=&#39;underscore_&#39;)          # metadata
    write_data(&#39;audio/file.npz&#39;, data, rate, &#39;mV&#39;, md)
    ```
    &#34;&#34;&#34;
    if not format:
        format = format_from_extension(filepath)
    if not format:
        raise ValueError(&#39;unspecified file format&#39;)
    for fmt, lib, formats_func in data_formats_funcs:
        if lib and not data_modules[lib]:
            continue
        if format.upper() in formats_func():
            writer_func = data_writer_funcs[fmt]
            filepath = writer_func(filepath, data, rate, amax,
                                   unit, metadata, locs, labels,
                                   format=format, encoding=encoding,
                                   **kwargs)
            if verbose &gt; 0:
                print(f&#39;wrote data to file &#34;{filepath}&#34; using {fmt} format&#39;)
                if verbose &gt; 1:
                    print(f&#39;  sampling rate: {rate:g}Hz&#39;)
                    print(f&#39;  channels     : {data.shape[1] if len(data.shape) &gt; 1 else 1}&#39;)
                    print(f&#39;  frames       : {len(data)}&#39;)
                    print(f&#39;  range        : {amax:g}{unit}&#39;)
            return filepath
    raise IOError(f&#39;file format &#34;{format.upper()}&#34; not supported.&#39;) </code></pre>
</details>
<div class="desc"><p>Write data into a file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>str</code> or <code>Path</code></dt>
<dd>Full path and name of the file to write.
File format is determined from extension.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>1-D</code> or <code>2-D array</code> of <code>floats</code></dt>
<dd>Array with the data (first index time, second index channel).</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Sampling rate of the data in Hertz.</dd>
<dt><strong><code>amax</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum possible amplitude of the data in <code>unit</code>.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>Unit of the data.</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>nested dict</code></dt>
<dd>Additional metadata.</dd>
<dt><strong><code>locs</code></strong> :&ensp;<code>None</code> or <code>1-D</code> or <code>2-D array</code> of <code>ints</code></dt>
<dd>Marker positions (first column) and spans (optional second column)
for each marker (rows).</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>None</code> or <code>2-D array</code> of <code>string objects</code></dt>
<dd>Labels (first column) and texts (optional second column)
for each marker (rows).</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>File format. If None deduce file format from filepath.
See <code><a title="thunderlab.datawriter.available_formats" href="#thunderlab.datawriter.available_formats">available_formats()</a></code> for possible values.</dd>
<dt><strong><code>encoding</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>Encoding of the data. See <code><a title="thunderlab.datawriter.available_encodings" href="#thunderlab.datawriter.available_encodings">available_encodings()</a></code> for possible values.
If None or empty string use 'PCM_16'.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>int</code></dt>
<dd>If &gt;0 show detailed error/warning messages.</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Additional, file format specific keyword arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>On success, the actual file name used for writing the data.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Unspecified file format.</dd>
<dt><code>IOError</code></dt>
<dd>Requested file format not supported.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>import numpy as np
from thunderlab.datawriter import write_data

rate = 28000.0
freq = 800.0
time = np.arange(0.0, 1.0, 1/rate)     # one second
data = 2.5*np.sin(2.0*np.p*freq*time)        # 800Hz sine wave
md = dict(Artist='underscore_')          # metadata
write_data('audio/file.npz', data, rate, 'mV', md)
</code></pre></div>
</dd>
<dt id="thunderlab.datawriter.demo"><code class="name flex">
<span>def <span class="ident">demo</span></span>(<span>file_path, channels=2, format=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def demo(file_path, channels=2, format=None):
    &#34;&#34;&#34;Demo of the datawriter functions.

    Parameters
    ----------
    file_path: str
        File path of a data file.
    format: str or None
        File format to be used.
    &#34;&#34;&#34;
    print(&#39;generate data ...&#39;)
    rate = 44100.0
    t = np.arange(0.0, 1.0, 1.0/rate)
    data = np.zeros((len(t), channels))
    for c in range(channels):
        data[:,c] = 0.1*(channels-c)*np.sin(2.0*np.pi*(440.0+c*8.0)*t)
        
    print(f&#34;write_data(&#39;{file_path}&#39;) ...&#34;)
    write_data(file_path, data, rate, 1.0, &#39;mV&#39;, format=format, verbose=2)

    print(&#39;done.&#39;)</code></pre>
</details>
<div class="desc"><p>Demo of the datawriter functions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>File path of a data file.</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>File format to be used.</dd>
</dl></div>
</dd>
<dt id="thunderlab.datawriter.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>*cargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(*cargs):
    &#34;&#34;&#34;Call demo with command line arguments.

    Parameters
    ----------
    cargs: list of str
        Command line arguments as provided by sys.argv[1:]
    &#34;&#34;&#34;
    import argparse
    parser = argparse.ArgumentParser(description=
                                     &#39;Checking thunderlab.datawriter module.&#39;)
    parser.add_argument(&#39;-c&#39;, dest=&#39;channels&#39;, default=2, type=int,
                        help=&#39;number of channels to be written&#39;)
    parser.add_argument(&#39;-f&#39;, dest=&#39;format&#39;, default=None, type=str,
                        help=&#39;file format&#39;)
    parser.add_argument(&#39;file&#39;, nargs=1, default=&#39;test.npz&#39;, type=str,
                        help=&#39;name of data file&#39;)
    args = parser.parse_args(cargs)
    demo(args.file[0], args.channels, args.format)</code></pre>
</details>
<div class="desc"><p>Call demo with command line arguments.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cargs</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>Command line arguments as provided by sys.argv[1:]</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="thunderlab" href="index.html">thunderlab</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="thunderlab.datawriter.data_modules" href="#thunderlab.datawriter.data_modules">data_modules</a></code></li>
<li><code><a title="thunderlab.datawriter.data_formats_funcs" href="#thunderlab.datawriter.data_formats_funcs">data_formats_funcs</a></code></li>
<li><code><a title="thunderlab.datawriter.data_encodings_funcs" href="#thunderlab.datawriter.data_encodings_funcs">data_encodings_funcs</a></code></li>
<li><code><a title="thunderlab.datawriter.data_writer_funcs" href="#thunderlab.datawriter.data_writer_funcs">data_writer_funcs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="thunderlab.datawriter.format_from_extension" href="#thunderlab.datawriter.format_from_extension">format_from_extension</a></code></li>
<li><code><a title="thunderlab.datawriter.recode_array" href="#thunderlab.datawriter.recode_array">recode_array</a></code></li>
<li><code><a title="thunderlab.datawriter.formats_relacs" href="#thunderlab.datawriter.formats_relacs">formats_relacs</a></code></li>
<li><code><a title="thunderlab.datawriter.encodings_relacs" href="#thunderlab.datawriter.encodings_relacs">encodings_relacs</a></code></li>
<li><code><a title="thunderlab.datawriter.write_relacs" href="#thunderlab.datawriter.write_relacs">write_relacs</a></code></li>
<li><code><a title="thunderlab.datawriter.formats_fishgrid" href="#thunderlab.datawriter.formats_fishgrid">formats_fishgrid</a></code></li>
<li><code><a title="thunderlab.datawriter.encodings_fishgrid" href="#thunderlab.datawriter.encodings_fishgrid">encodings_fishgrid</a></code></li>
<li><code><a title="thunderlab.datawriter.write_fishgrid" href="#thunderlab.datawriter.write_fishgrid">write_fishgrid</a></code></li>
<li><code><a title="thunderlab.datawriter.formats_pickle" href="#thunderlab.datawriter.formats_pickle">formats_pickle</a></code></li>
<li><code><a title="thunderlab.datawriter.encodings_pickle" href="#thunderlab.datawriter.encodings_pickle">encodings_pickle</a></code></li>
<li><code><a title="thunderlab.datawriter.write_pickle" href="#thunderlab.datawriter.write_pickle">write_pickle</a></code></li>
<li><code><a title="thunderlab.datawriter.insert_container_metadata" href="#thunderlab.datawriter.insert_container_metadata">insert_container_metadata</a></code></li>
<li><code><a title="thunderlab.datawriter.formats_numpy" href="#thunderlab.datawriter.formats_numpy">formats_numpy</a></code></li>
<li><code><a title="thunderlab.datawriter.encodings_numpy" href="#thunderlab.datawriter.encodings_numpy">encodings_numpy</a></code></li>
<li><code><a title="thunderlab.datawriter.write_numpy" href="#thunderlab.datawriter.write_numpy">write_numpy</a></code></li>
<li><code><a title="thunderlab.datawriter.formats_mat" href="#thunderlab.datawriter.formats_mat">formats_mat</a></code></li>
<li><code><a title="thunderlab.datawriter.encodings_mat" href="#thunderlab.datawriter.encodings_mat">encodings_mat</a></code></li>
<li><code><a title="thunderlab.datawriter.write_mat" href="#thunderlab.datawriter.write_mat">write_mat</a></code></li>
<li><code><a title="thunderlab.datawriter.formats_raw" href="#thunderlab.datawriter.formats_raw">formats_raw</a></code></li>
<li><code><a title="thunderlab.datawriter.encodings_raw" href="#thunderlab.datawriter.encodings_raw">encodings_raw</a></code></li>
<li><code><a title="thunderlab.datawriter.write_raw" href="#thunderlab.datawriter.write_raw">write_raw</a></code></li>
<li><code><a title="thunderlab.datawriter.formats_audioio" href="#thunderlab.datawriter.formats_audioio">formats_audioio</a></code></li>
<li><code><a title="thunderlab.datawriter.encodings_audio" href="#thunderlab.datawriter.encodings_audio">encodings_audio</a></code></li>
<li><code><a title="thunderlab.datawriter.write_audioio" href="#thunderlab.datawriter.write_audioio">write_audioio</a></code></li>
<li><code><a title="thunderlab.datawriter.available_formats" href="#thunderlab.datawriter.available_formats">available_formats</a></code></li>
<li><code><a title="thunderlab.datawriter.available_encodings" href="#thunderlab.datawriter.available_encodings">available_encodings</a></code></li>
<li><code><a title="thunderlab.datawriter.write_data" href="#thunderlab.datawriter.write_data">write_data</a></code></li>
<li><code><a title="thunderlab.datawriter.demo" href="#thunderlab.datawriter.demo">demo</a></code></li>
<li><code><a title="thunderlab.datawriter.main" href="#thunderlab.datawriter.main">main</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
