<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>thunderlab.powerspectrum API documentation</title>
<meta name="description" content="Powerspectra and spectrograms for a given frequency resolution â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>thunderlab.powerspectrum</code></h1>
</header>
<section id="section-intro">
<p>Powerspectra and spectrograms for a given frequency resolution</p>
<h2 id="computation-of-nfft">Computation of nfft</h2>
<ul>
<li><code><a title="thunderlab.powerspectrum.next_power_of_two" href="#thunderlab.powerspectrum.next_power_of_two">next_power_of_two()</a></code>: round an integer up to the next power of two.</li>
<li><code><a title="thunderlab.powerspectrum.nfft" href="#thunderlab.powerspectrum.nfft">nfft()</a></code>: compute nfft based on a given frequency resolution.</li>
</ul>
<h2 id="decibel">Decibel</h2>
<ul>
<li><code><a title="thunderlab.powerspectrum.decibel" href="#thunderlab.powerspectrum.decibel">decibel()</a></code>: transform power to decibel.</li>
<li><code><a title="thunderlab.powerspectrum.power" href="#thunderlab.powerspectrum.power">power()</a></code>: transform decibel to power.</li>
</ul>
<h2 id="power-spectra">Power spectra</h2>
<ul>
<li><code><a title="thunderlab.powerspectrum.psd" href="#thunderlab.powerspectrum.psd">psd()</a></code>: power spectrum for a given frequency resolution.</li>
<li><code><a title="thunderlab.powerspectrum.spectrogram" href="#thunderlab.powerspectrum.spectrogram">spectrogram()</a></code>: spectrogram of a given frequency resolution and overlap fraction.</li>
</ul>
<h2 id="power-spectrum-analysis">Power spectrum analysis</h2>
<ul>
<li><code><a title="thunderlab.powerspectrum.peak_freqs" href="#thunderlab.powerspectrum.peak_freqs">peak_freqs()</a></code>: peak frequencies computed from power spectra of data snippets.</li>
</ul>
<h2 id="visualization">Visualization</h2>
<ul>
<li><code><a title="thunderlab.powerspectrum.plot_decibel_psd" href="#thunderlab.powerspectrum.plot_decibel_psd">plot_decibel_psd()</a></code>: plot power spectrum in decibel.</li>
</ul>
<h2 id="configuration-parameter">Configuration parameter</h2>
<ul>
<li><code><a title="thunderlab.powerspectrum.add_spectrum_config" href="#thunderlab.powerspectrum.add_spectrum_config">add_spectrum_config()</a></code>: add parameters for psd() and spectrogram() to configuration.</li>
<li><code>sepctrum_args()</code>: retrieve parameters for psd() and spectrogram() from configuration.</li>
</ul>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="thunderlab.powerspectrum.next_power_of_two"><code class="name flex">
<span>def <span class="ident">next_power_of_two</span></span>(<span>n)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def next_power_of_two(n):
    &#34;&#34;&#34;The next integer power of two.
    
    Parameters
    ----------
    n: int
        A positive number.

    Returns
    -------
    m: int
        The next integer power of two equal or larger than `n`.
    &#34;&#34;&#34;
    return int(2 ** np.floor(np.log(n) / np.log(2.0) + 1.0 - 1e-8))</code></pre>
</details>
<div class="desc"><p>The next integer power of two.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>A positive number.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>m</code></strong> :&ensp;<code>int</code></dt>
<dd>The next integer power of two equal or larger than <code>n</code>.</dd>
</dl></div>
</dd>
<dt id="thunderlab.powerspectrum.nfft"><code class="name flex">
<span>def <span class="ident">nfft</span></span>(<span>rate, freq_resolution, min_nfft=16, max_nfft=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nfft(rate, freq_resolution, min_nfft=16, max_nfft=None):
    &#34;&#34;&#34;Required number of samples for an FFT of a given frequency resolution.

    Note that the returned number of FFT samples results
    in frequency intervals that are smaller or equal to `freq_resolution`.

    Parameters
    ----------
    rate: float
        Sampling rate of the data in Hertz.
    freq_resolution: float
        Minimum frequency resolution in Hertz.
    min_nfft: int
        Smallest value of nfft to be used.
    max_nfft: int or None
        If not None, largest value of nfft to be used.

    Returns
    -------
    nfft: int
        Number of FFT points.
    &#34;&#34;&#34;
    nfft = next_power_of_two(rate / freq_resolution)
    if not max_nfft is None:
        if nfft &gt; max_nfft:
            nfft = next_power_of_two(max_nfft//2 + 1)
    if nfft &lt; min_nfft:
        nfft = min_nfft
    return nfft</code></pre>
</details>
<div class="desc"><p>Required number of samples for an FFT of a given frequency resolution.</p>
<p>Note that the returned number of FFT samples results
in frequency intervals that are smaller or equal to <code>freq_resolution</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Sampling rate of the data in Hertz.</dd>
<dt><strong><code>freq_resolution</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum frequency resolution in Hertz.</dd>
<dt><strong><code>min_nfft</code></strong> :&ensp;<code>int</code></dt>
<dd>Smallest value of nfft to be used.</dd>
<dt><strong><code>max_nfft</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>If not None, largest value of nfft to be used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>nfft</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of FFT points.</dd>
</dl></div>
</dd>
<dt id="thunderlab.powerspectrum.decibel"><code class="name flex">
<span>def <span class="ident">decibel</span></span>(<span>power, ref_power=1.0, min_power=1e-20)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decibel(power, ref_power=1.0, min_power=1e-20):
    &#34;&#34;&#34;Transform power to decibel relative to ref_power.

    \\[ decibel = 10 \\cdot \\log_{10}(power/ref\\_power) \\]
    Power values smaller than `min_power` are set to `-np.inf`.

    Parameters
    ----------
    power: float or array
        Power values, for example from a power spectrum or spectrogram.
    ref_power: float or None or &#39;peak&#39;
        Reference power for computing decibel.
        If set to `None` or &#39;peak&#39;, the maximum power is used.
    min_power: float
        Power values smaller than `min_power` are set to `-np.inf`.

    Returns
    -------
    decibel_psd: array
        Power values in decibel relative to `ref_power`.
    &#34;&#34;&#34;
    if np.isscalar(power):
        tmp_power = np.array([power])
        decibel_psd = np.array([power])
    else:
        tmp_power = power
        decibel_psd = power.copy()
    if ref_power is None or ref_power == &#39;peak&#39;:
        ref_power = np.max(decibel_psd)
    decibel_psd[tmp_power &lt;= min_power] = float(&#39;-inf&#39;)
    decibel_psd[tmp_power &gt; min_power] = 10.0 * np.log10(decibel_psd[tmp_power &gt; min_power]/ref_power)
    if np.isscalar(power):
        return decibel_psd[0]
    else:
        return decibel_psd</code></pre>
</details>
<div class="desc"><p>Transform power to decibel relative to ref_power.</p>
<p><span><span class="MathJax_Preview"> decibel = 10 \cdot \log_{10}(power/ref\_power) </span><script type="math/tex; mode=display"> decibel = 10 \cdot \log_{10}(power/ref\_power) </script></span>
Power values smaller than <code>min_power</code> are set to <code>-np.inf</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>power</code></strong> :&ensp;<code>float</code> or <code>array</code></dt>
<dd>Power values, for example from a power spectrum or spectrogram.</dd>
<dt><strong><code>ref_power</code></strong> :&ensp;<code>float</code> or <code>None</code> or <code>'peak'</code></dt>
<dd>Reference power for computing decibel.
If set to <code>None</code> or 'peak', the maximum power is used.</dd>
<dt><strong><code>min_power</code></strong> :&ensp;<code>float</code></dt>
<dd>Power values smaller than <code>min_power</code> are set to <code>-np.inf</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>decibel_psd</code></strong> :&ensp;<code>array</code></dt>
<dd>Power values in decibel relative to <code>ref_power</code>.</dd>
</dl></div>
</dd>
<dt id="thunderlab.powerspectrum.power"><code class="name flex">
<span>def <span class="ident">power</span></span>(<span>decibel, ref_power=1.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def power(decibel, ref_power=1.0):
    &#34;&#34;&#34;Transform decibel back to power relative to `ref_power`.

    \\[ power = ref\\_power \\cdot 10^{decibel/10} \\]
    
    Parameters
    ----------
    decibel: array
        Decibel values of the power spectrum or spectrogram.
    ref_power: float
        Reference power for computing power.

    Returns
    -------
    power: array
        Power values of the power spectrum or spectrogram.
    &#34;&#34;&#34;
    return ref_power * 10.0 ** (0.1 * decibel)</code></pre>
</details>
<div class="desc"><p>Transform decibel back to power relative to <code>ref_power</code>.</p>
<p><span><span class="MathJax_Preview"> power = ref\_power \cdot 10^{decibel/10} </span><script type="math/tex; mode=display"> power = ref\_power \cdot 10^{decibel/10} </script></span></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>decibel</code></strong> :&ensp;<code>array</code></dt>
<dd>Decibel values of the power spectrum or spectrogram.</dd>
<dt><strong><code>ref_power</code></strong> :&ensp;<code>float</code></dt>
<dd>Reference power for computing power.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>power</code></strong> :&ensp;<code>array</code></dt>
<dd>Power values of the power spectrum or spectrogram.</dd>
</dl></div>
</dd>
<dt id="thunderlab.powerspectrum.psd"><code class="name flex">
<span>def <span class="ident">psd</span></span>(<span>data,<br>ratetime,<br>freq_resolution=1.0,<br>overlap_frac=0.5,<br>n_fft=None,<br>n_overlap=None,<br>min_nfft=16,<br>max_nfft=None,<br>detrend='constant',<br>window='hann')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def psd(data, ratetime, freq_resolution=1.0, overlap_frac=0.5,
        n_fft=None, n_overlap=None, min_nfft=16, max_nfft=None,
        detrend=&#39;constant&#39;, window=&#39;hann&#39;):
    &#34;&#34;&#34;Power spectrum density of a given frequency resolution.

    If `freq_resolution` is given, the number of samples used for each
    FFT segment is computed from the requested frequency resolution
    and the sampling rate.  Check the returned frequency array for the
    actually used frequency resolution.  The frequency intervals are
    smaller or equal to `freq_resolution`.  The actually used number
    of samples used for each FFT segment can be retrieved by dividing
    the sampling rate by the actual frequency resolution:
    ```
    freq, power = psd(data, samplingrate, 0.1)
    df = np.mean(np.diff(freq))  # the actual frequency resolution
    nfft = int(samplingrate/df)
    ```

    Uses `scipy signal.welch()` if available, otherwise
    `matplotlib.mlab.psd()`.

    Parameters
    ----------
    data: 1-D array 
        Data from which power spectra are computed.
    ratetime: float or array
        If float, sampling rate of the data in Hertz.
        If array, assume `ratetime` to be the time array
        corresponding to the data.
        Compute sampling rate as `1/(ratetime[1]-ratetime[0])`.
    freq_resolution: float or None
        Desired frequency resolution of the power spectrum in Hertz.
        See `nfft()` for details.
        Alternatively, the number of samples used for computing FFTs
        can be specified by the `n_fft` argument.
    overlap_frac: float or None
        Fraction of overlap between subsequent FFT segments
        (0: no overlap, 1: complete overlap).
        Alternatively, the overlap can be specified by the `n_overlap` argument.
    n_fft: int or None
        If `freq_resolution` is None, then this is the number of
        samples used for each FFT segment.
    n_overlap: int or None    
        If `overlap_frac` is None, then this is the number of
        samples subsequent FFT segments overlap.
    min_nfft: int
        Smallest value of nfft to be used.
    max_nfft: int or None
        If not None, largest value of nfft to be used.
    detrend: string
        If &#39;constant&#39; or &#39;mean&#39; subtract mean of data.
        If &#39;linear&#39; subtract line fitted to the data.
        If &#39;none&#39; do not detrend the data.
    window: string
        Function used for windowing data segements.
        One of hann, blackman, hamming, bartlett, boxcar, triang, parzen,
        bohman, blackmanharris, nuttall, fattop, barthann
        (see scipy.signal window functions).

    Returns
    -------
    freq: 1-D array
        Frequencies corresponding to `power` array.
    power: 1-D array
        Power spectral density in [data]^2/Hz.

    Raises
    ------
    ValueError:
        Both, `freq_resolution`and `n_fft` are not specified, or
        both, `overlap_frac`and `n_overlap` are not specified.
    &#34;&#34;&#34;
    rate = ratetime if np.isscalar(ratetime) else 1.0/(ratetime[1]-ratetime[0])
    if freq_resolution is not None:
        n_fft = nfft(rate, freq_resolution, min_nfft, max_nfft)
    if n_fft is None:
        raise ValueError(&#39;freq_resolution or n_fft needs to be specified&#39;)
    if overlap_frac is not None:
        n_overlap = int(n_fft*overlap_frac)
    if n_overlap is None:
        raise ValueError(&#39;overlap_frac or n_overlap needs to be specified&#39;)
    if n_fft &gt;= len(data):
        n_overlap = len(data) - 1
    if psdscipy:
        if detrend == &#39;none&#39;:
            detrend = False
        elif detrend == &#39;mean&#39;:
            detrend = &#39;constant&#39;
        freqs, power = swelch(data, fs=rate, nperseg=n_fft, nfft=None,
                              noverlap=n_overlap, detrend=detrend,
                              window=window, scaling=&#39;density&#39;)
    else:
        if detrend == &#39;constant&#39;:
            detrend = &#39;mean&#39;
        power, freqs = mpsd(data, Fs=rate, NFFT=n_fft,
                            noverlap=n_overlap, detrend=detrend,
                            window=get_window(window, n_fft),
                            scale_by_freq=True)
    # squeeze is necessary when n_fft is too large with respect to the data:
    return freqs, np.squeeze(power)</code></pre>
</details>
<div class="desc"><p>Power spectrum density of a given frequency resolution.</p>
<p>If <code>freq_resolution</code> is given, the number of samples used for each
FFT segment is computed from the requested frequency resolution
and the sampling rate.
Check the returned frequency array for the
actually used frequency resolution.
The frequency intervals are
smaller or equal to <code>freq_resolution</code>.
The actually used number
of samples used for each FFT segment can be retrieved by dividing
the sampling rate by the actual frequency resolution:</p>
<pre><code>freq, power = psd(data, samplingrate, 0.1)
df = np.mean(np.diff(freq))  # the actual frequency resolution
nfft = int(samplingrate/df)
</code></pre>
<p>Uses <code>scipy signal.welch()</code> if available, otherwise
<code>matplotlib.mlab.psd()</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>1-D array</code></dt>
<dd>Data from which power spectra are computed.</dd>
<dt><strong><code>ratetime</code></strong> :&ensp;<code>float</code> or <code>array</code></dt>
<dd>If float, sampling rate of the data in Hertz.
If array, assume <code>ratetime</code> to be the time array
corresponding to the data.
Compute sampling rate as <code>1/(ratetime[1]-ratetime[0])</code>.</dd>
<dt><strong><code>freq_resolution</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>Desired frequency resolution of the power spectrum in Hertz.
See <code><a title="thunderlab.powerspectrum.nfft" href="#thunderlab.powerspectrum.nfft">nfft()</a></code> for details.
Alternatively, the number of samples used for computing FFTs
can be specified by the <code>n_fft</code> argument.</dd>
<dt><strong><code>overlap_frac</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>Fraction of overlap between subsequent FFT segments
(0: no overlap, 1: complete overlap).
Alternatively, the overlap can be specified by the <code>n_overlap</code> argument.</dd>
<dt><strong><code>n_fft</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>If <code>freq_resolution</code> is None, then this is the number of
samples used for each FFT segment.</dd>
<dt><strong><code>n_overlap</code></strong> :&ensp;<code>int</code> or <code>None
</code></dt>
<dd>If <code>overlap_frac</code> is None, then this is the number of
samples subsequent FFT segments overlap.</dd>
<dt><strong><code>min_nfft</code></strong> :&ensp;<code>int</code></dt>
<dd>Smallest value of nfft to be used.</dd>
<dt><strong><code>max_nfft</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>If not None, largest value of nfft to be used.</dd>
<dt><strong><code>detrend</code></strong> :&ensp;<code>string</code></dt>
<dd>If 'constant' or 'mean' subtract mean of data.
If 'linear' subtract line fitted to the data.
If 'none' do not detrend the data.</dd>
<dt><strong><code>window</code></strong> :&ensp;<code>string</code></dt>
<dd>Function used for windowing data segements.
One of hann, blackman, hamming, bartlett, boxcar, triang, parzen,
bohman, blackmanharris, nuttall, fattop, barthann
(see scipy.signal window functions).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>freq</code></strong> :&ensp;<code>1-D array</code></dt>
<dd>Frequencies corresponding to <code><a title="thunderlab.powerspectrum.power" href="#thunderlab.powerspectrum.power">power()</a></code> array.</dd>
<dt><strong><code>power</code></strong> :&ensp;<code>1-D array</code></dt>
<dd>Power spectral density in [data]^2/Hz.</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="valueerror">Valueerror</h2>
<p>Both, <code>freq_resolution</code>and <code>n_fft</code> are not specified, or
both, <code>overlap_frac</code>and <code>n_overlap</code> are not specified.</p></div>
</dd>
<dt id="thunderlab.powerspectrum.spectrogram"><code class="name flex">
<span>def <span class="ident">spectrogram</span></span>(<span>data,<br>ratetime,<br>freq_resolution=1.0,<br>overlap_frac=0.5,<br>n_fft=None,<br>n_overlap=None,<br>min_nfft=16,<br>max_nfft=None,<br>detrend='constant',<br>window='hann')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spectrogram(data, ratetime, freq_resolution=1.0, overlap_frac=0.5,
                n_fft=None, n_overlap=None, min_nfft=16, max_nfft=None,
                detrend=&#39;constant&#39;, window=&#39;hann&#39;):
    &#34;&#34;&#34;Spectrogram of a given frequency resolution.

    Check the returned frequency array for the actually used frequency
    resolution.
    The actual frequency resolution is smaller or equal to `freq_resolution`.
    The used number of data points per FFT segment (NFFT) is the
    sampling rate divided by the actual frequency resolution:

    ```
    freqs, times, spec = spectrum(data, samplingrate, 0.1) # request 0.1Hz resolution
    df = np.mean(np.diff(freq))  # the actual frequency resolution
    df = freqs[1]                # same
    nfft = int(samplingrate/df)
    ```

    You can plot the spectrogram directly with `pcolormesh()` with
    `shading=&#39;nearest&#39;` (default):

    ```
    fig, ax = plt.subplots()
    ax.pcolormesh(times, freqs, decibel(spec),
                   vmin=-100, shading=&#39;nearest&#39;)
    ```

    Uses `scipy signal.spectrogram()` if available, otherwise
    `matplotlib.mlab.specgram()`.
    
    Parameters
    ----------
    data: 1D or 2D array of floats
        Data for the spectrograms. First dimension is time,
        optional second dimension is channel.
    ratetime: float or array
        If float, sampling rate of the data in Hertz.
        If array, assume `ratetime` to be the time array
        corresponding to the data.
        The sampling rate is then computed as `1/(ratetime[1]-ratetime[0])`.
    freq_resolution: float
        Desired frequency resolution of the spectrogram in Hertz.
        See `nfft()` for details.
        Alternatively, the number of samples used for computing FFTs
        can be specified by the `n_fft` argument.
    overlap_frac: float
        Fraction of overlap between subsequent FFT segments
        (0: no overlap, 1: complete overlap).
        Alternatively, the overlap can be specified by the `n_overlap` argument.
    n_fft: int or None
        If `freq_resolution` is None, then this is the number of
        samples used for each FFT segment.
    n_overlap: int or None    
        If `overlap_frac` is None, then this is the number of
        samples subsequent FFT segments overlap.
    min_nfft: int
        Smallest value of nfft to be used. See `nfft()` for details.
    max_nfft: int or None
        If not None, largest value of nfft to be used.
        See `nfft()` for details.
    detrend: string or False
        If &#39;constant&#39; subtract mean of each data segment.
        If &#39;linear&#39; subtract line fitted to each data segment.
        If `False` do not detrend the data segments.
    window: string
        Function used for windowing data segements.
        One of hann, blackman, hamming, bartlett, boxcar, triang, parzen,
        bohman, blackmanharris, nuttall, fattop, barthann, tukey
        (see scipy.signal window functions).

    Returns
    -------
    freqs: array
        Frequencies of the spectrogram.
        First element is zero. Second element is frequency resolution.
    time: array
        Times of the nfft segments, centered on the segments.
    spectrum: 2D or 3D array
        Power spectral density for each frequency and time.
        First dimension is frequency and second dimension is time.
        Optional last dimension is channel.

    Raises
    ------
    ValueError:
        Both, `freq_resolution`and `n_fft` are not specified, or
        both, `overlap_frac`and `n_overlap` are not specified.
    &#34;&#34;&#34;
    rate = ratetime if np.isscalar(ratetime) else 1.0/(ratetime[1]-ratetime[0])
    if freq_resolution is not None:
        n_fft = nfft(rate, freq_resolution, min_nfft, max_nfft)
    if n_fft is None:
        raise ValueError(&#39;freq_resolution or n_fft needs to be specified&#39;)
    if overlap_frac is not None:
        n_overlap = int(n_fft*overlap_frac)
    if n_overlap is None:
        raise ValueError(&#39;overlap_frac or n_overlap needs to be specified&#39;)
    if n_fft &gt;= len(data):
        n_overlap = len(data) - 1
    if specgramscipy:
        freqs, time, spec = sspectrogram(data, fs=rate, window=window,
                                         nperseg=n_fft, noverlap=n_overlap,
                                         detrend=detrend, scaling=&#39;density&#39;,
                                         mode=&#39;psd&#39;, axis=0)
        if data.ndim &gt; 1:
            # scipy spectrogram() returns f x n x t:
            spec = np.transpose(spec, (0, 2, 1))
    else:
        if data.ndim &gt; 1:
            spec = None
            for k in range(data.shape[1]):
                try:
                    ssx, freqs, time = mspecgram(data[:,k], NFFT=n_fft, Fs=rate,
                                                 noverlap=n_overlap,
                                                 detrend=detrend,
                                                 scale_by_freq=True,
                                                 scale=&#39;linear&#39;,
                                                 mode=&#39;psd&#39;,
                                                 window=get_window(window, n_fft))
                except TypeError:
                    ssx, freqs, time = mspecgram(data[:,k], NFFT=n_fft, Fs=rate,
                                                 noverlap=n_overlap,
                                                 detrend=detrend,
                                                 scale_by_freq=True,
                                                 window=get_window(window, n_fft))
                if spec is None:
                    spec = np.zeros((len(freqs), len(time), data.shape[1]))
                spec[:, :, k] = ssx
        else:
            try:
                spec, freqs, time = mspecgram(data, NFFT=n_fft, Fs=rate,
                                              noverlap=n_overlap,
                                              detrend=detrend,
                                              scale_by_freq=True,
                                              scale=&#39;linear&#39;,
                                              mode=&#39;psd&#39;,
                                              window=get_window(window, n_fft))
            except TypeError:
                spec, freqs, time = mspecgram(data, NFFT=n_fft, Fs=rate,
                                              noverlap=n_overlap,
                                              detrend=detrend,
                                              scale_by_freq=True,
                                              window=get_window(window, n_fft))
    return freqs, time, spec</code></pre>
</details>
<div class="desc"><p>Spectrogram of a given frequency resolution.</p>
<p>Check the returned frequency array for the actually used frequency
resolution.
The actual frequency resolution is smaller or equal to <code>freq_resolution</code>.
The used number of data points per FFT segment (NFFT) is the
sampling rate divided by the actual frequency resolution:</p>
<pre><code>freqs, times, spec = spectrum(data, samplingrate, 0.1) # request 0.1Hz resolution
df = np.mean(np.diff(freq))  # the actual frequency resolution
df = freqs[1]                # same
nfft = int(samplingrate/df)
</code></pre>
<p>You can plot the spectrogram directly with <code>pcolormesh()</code> with
<code>shading='nearest'</code> (default):</p>
<pre><code>fig, ax = plt.subplots()
ax.pcolormesh(times, freqs, decibel(spec),
               vmin=-100, shading='nearest')
</code></pre>
<p>Uses <code>scipy signal.spectrogram()</code> if available, otherwise
<code>matplotlib.mlab.specgram()</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>1D</code> or <code>2D array</code> of <code>floats</code></dt>
<dd>Data for the spectrograms. First dimension is time,
optional second dimension is channel.</dd>
<dt><strong><code>ratetime</code></strong> :&ensp;<code>float</code> or <code>array</code></dt>
<dd>If float, sampling rate of the data in Hertz.
If array, assume <code>ratetime</code> to be the time array
corresponding to the data.
The sampling rate is then computed as <code>1/(ratetime[1]-ratetime[0])</code>.</dd>
<dt><strong><code>freq_resolution</code></strong> :&ensp;<code>float</code></dt>
<dd>Desired frequency resolution of the spectrogram in Hertz.
See <code><a title="thunderlab.powerspectrum.nfft" href="#thunderlab.powerspectrum.nfft">nfft()</a></code> for details.
Alternatively, the number of samples used for computing FFTs
can be specified by the <code>n_fft</code> argument.</dd>
<dt><strong><code>overlap_frac</code></strong> :&ensp;<code>float</code></dt>
<dd>Fraction of overlap between subsequent FFT segments
(0: no overlap, 1: complete overlap).
Alternatively, the overlap can be specified by the <code>n_overlap</code> argument.</dd>
<dt><strong><code>n_fft</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>If <code>freq_resolution</code> is None, then this is the number of
samples used for each FFT segment.</dd>
<dt><strong><code>n_overlap</code></strong> :&ensp;<code>int</code> or <code>None
</code></dt>
<dd>If <code>overlap_frac</code> is None, then this is the number of
samples subsequent FFT segments overlap.</dd>
<dt><strong><code>min_nfft</code></strong> :&ensp;<code>int</code></dt>
<dd>Smallest value of nfft to be used. See <code><a title="thunderlab.powerspectrum.nfft" href="#thunderlab.powerspectrum.nfft">nfft()</a></code> for details.</dd>
<dt><strong><code>max_nfft</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>If not None, largest value of nfft to be used.
See <code><a title="thunderlab.powerspectrum.nfft" href="#thunderlab.powerspectrum.nfft">nfft()</a></code> for details.</dd>
<dt><strong><code>detrend</code></strong> :&ensp;<code>string</code> or <code>False</code></dt>
<dd>If 'constant' subtract mean of each data segment.
If 'linear' subtract line fitted to each data segment.
If <code>False</code> do not detrend the data segments.</dd>
<dt><strong><code>window</code></strong> :&ensp;<code>string</code></dt>
<dd>Function used for windowing data segements.
One of hann, blackman, hamming, bartlett, boxcar, triang, parzen,
bohman, blackmanharris, nuttall, fattop, barthann, tukey
(see scipy.signal window functions).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>freqs</code></strong> :&ensp;<code>array</code></dt>
<dd>Frequencies of the spectrogram.
First element is zero. Second element is frequency resolution.</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>array</code></dt>
<dd>Times of the nfft segments, centered on the segments.</dd>
<dt><strong><code>spectrum</code></strong> :&ensp;<code>2D</code> or <code>3D array</code></dt>
<dd>Power spectral density for each frequency and time.
First dimension is frequency and second dimension is time.
Optional last dimension is channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="valueerror">Valueerror</h2>
<p>Both, <code>freq_resolution</code>and <code>n_fft</code> are not specified, or
both, <code>overlap_frac</code>and <code>n_overlap</code> are not specified.</p></div>
</dd>
<dt id="thunderlab.powerspectrum.plot_decibel_psd"><code class="name flex">
<span>def <span class="ident">plot_decibel_psd</span></span>(<span>ax,<br>freqs,<br>power,<br>ref_power=1.0,<br>min_power=1e-20,<br>log_freq=False,<br>min_freq=0.0,<br>max_freq=2000.0,<br>ymarg=0.0,<br>sstyle={'color': 'tab:blue', 'lw': 1})</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_decibel_psd(ax, freqs, power, ref_power=1.0, min_power=1e-20,
                     log_freq=False, min_freq=0.0, max_freq=2000.0,
                     ymarg=0.0, sstyle=dict(color=&#39;tab:blue&#39;, lw=1)):
    &#34;&#34;&#34;Plot the powerspectum in decibel relative to `ref_power`.

    Parameters
    ----------
    ax:
        Axis for plot.
    freqs: 1-D array
        Frequency array of the power spectrum.
    power: 1-D array
        Power values of the power spectrum.
    ref_power: float
        Reference power for computing decibel. If set to `None` the maximum power is used.
    min_power: float
        Power values smaller than `min_power` are set to `np.nan`.
    log_freq: boolean
        Logarithmic (True) or linear (False) frequency axis.
    min_freq: float
        Limits of frequency axis are set to `(min_freq, max_freq)`
        if `max_freq` is greater than zero
    max_freq: float
        Limits of frequency axis are set to `(min_freq, max_freq)`
        and limits of power axis are computed from powers below max_freq
        if `max_freq` is greater than zero
    ymarg: float
        Add this to the maximum decibel power for setting the ylim.
    sstyle: dict
        Plot parameter that are passed on to the `plot()` function.
    &#34;&#34;&#34;
    decibel_psd = decibel(power, ref_power=ref_power, min_power=min_power)
    ax.plot(freqs, decibel_psd, **sstyle)
    ax.set_xlabel(&#39;Frequency [Hz]&#39;)
    if max_freq &gt; 0.0:
        if log_freq and min_freq &lt; 1e-8:
            min_freq = 1.0
        ax.set_xlim(min_freq, max_freq)
    else:
        max_freq = freqs[-1]
    if log_freq:
        ax.set_xscale(&#39;log&#39;)
    dpmf = decibel_psd[freqs &lt; max_freq]
    pmin = np.min(dpmf[np.isfinite(dpmf)])
    pmin = np.floor(pmin / 10.0) * 10.0
    pmax = np.max(dpmf[np.isfinite(dpmf)])
    pmax = np.ceil((pmax + ymarg) / 10.0) * 10.0
    ax.set_ylim(pmin, pmax)
    ax.set_ylabel(&#39;Power [dB]&#39;)</code></pre>
</details>
<div class="desc"><p>Plot the powerspectum in decibel relative to <code>ref_power</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>ax:</dt>
<dt>Axis for plot.</dt>
<dt><strong><code>freqs</code></strong> :&ensp;<code>1-D array</code></dt>
<dd>Frequency array of the power spectrum.</dd>
<dt><strong><code>power</code></strong> :&ensp;<code>1-D array</code></dt>
<dd>Power values of the power spectrum.</dd>
<dt><strong><code>ref_power</code></strong> :&ensp;<code>float</code></dt>
<dd>Reference power for computing decibel. If set to <code>None</code> the maximum power is used.</dd>
<dt><strong><code>min_power</code></strong> :&ensp;<code>float</code></dt>
<dd>Power values smaller than <code>min_power</code> are set to <code>np.nan</code>.</dd>
<dt><strong><code>log_freq</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Logarithmic (True) or linear (False) frequency axis.</dd>
<dt><strong><code>min_freq</code></strong> :&ensp;<code>float</code></dt>
<dd>Limits of frequency axis are set to <code>(min_freq, max_freq)</code>
if <code>max_freq</code> is greater than zero</dd>
<dt><strong><code>max_freq</code></strong> :&ensp;<code>float</code></dt>
<dd>Limits of frequency axis are set to <code>(min_freq, max_freq)</code>
and limits of power axis are computed from powers below max_freq
if <code>max_freq</code> is greater than zero</dd>
<dt><strong><code>ymarg</code></strong> :&ensp;<code>float</code></dt>
<dd>Add this to the maximum decibel power for setting the ylim.</dd>
<dt><strong><code>sstyle</code></strong> :&ensp;<code>dict</code></dt>
<dd>Plot parameter that are passed on to the <code>plot()</code> function.</dd>
</dl></div>
</dd>
<dt id="thunderlab.powerspectrum.peak_freqs"><code class="name flex">
<span>def <span class="ident">peak_freqs</span></span>(<span>onsets, offsets, data, rate, freq_resolution=1.0, thresh=None, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peak_freqs(onsets, offsets, data, rate, freq_resolution=1.0,
               thresh=None, **kwargs):
    &#34;&#34;&#34;Peak frequencies computed from power spectra of data snippets.

    Parameters
    ----------
    onsets: array of ints
        Indices indicating the onsets of the snippets in `data`.
    offsets: array of ints
        Indices indicating the offsets of the snippets in `data`.
    data: 1-D array
        Data array that contains the data snippets defined by
        `onsets` and `offsets`.
    rate: float
        Sampling rate of data in Hertz.
    freq_resolution: float
        Desired frequency resolution of the computed power spectra in Hertz.
    thresh: None or float
        If not None than this is the threshold required for the minimum height
        of the peak in the decibel power spectrum. If the peak is too small
        than the peak frequency of that snippet is set to NaN.
    kwargs: dict
        Further arguments passed on to psd().

    Returns
    -------
    freqs: array of floats
        For each data snippet the frequency of the maximum power.
    &#34;&#34;&#34;
    freqs = []
    for i0, i1 in zip(onsets, offsets):
        if &#39;max_nfft&#39; in kwargs:
            del kwargs[&#39;max_nfft&#39;]
        f, power = psd(data[i0:i1], rate, freq_resolution,
                       max_nfft=i1 - i0, **kwargs)
        if thresh is None:
            fpeak = f[np.argmax(power)]
        else:
            p, _ = detect_peaks(decibel(power, None), thresh)
            if len(p) &gt; 0:
                ipeak = np.argmax(power[p])
                fpeak = f[p[ipeak]]
            else:
                fpeak = float(&#39;NaN&#39;)
        freqs.append(fpeak)
    return np.array(freqs)</code></pre>
</details>
<div class="desc"><p>Peak frequencies computed from power spectra of data snippets.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>onsets</code></strong> :&ensp;<code>array</code> of <code>ints</code></dt>
<dd>Indices indicating the onsets of the snippets in <code>data</code>.</dd>
<dt><strong><code>offsets</code></strong> :&ensp;<code>array</code> of <code>ints</code></dt>
<dd>Indices indicating the offsets of the snippets in <code>data</code>.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>1-D array</code></dt>
<dd>Data array that contains the data snippets defined by
<code>onsets</code> and <code>offsets</code>.</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Sampling rate of data in Hertz.</dd>
<dt><strong><code>freq_resolution</code></strong> :&ensp;<code>float</code></dt>
<dd>Desired frequency resolution of the computed power spectra in Hertz.</dd>
<dt><strong><code>thresh</code></strong> :&ensp;<code>None</code> or <code>float</code></dt>
<dd>If not None than this is the threshold required for the minimum height
of the peak in the decibel power spectrum. If the peak is too small
than the peak frequency of that snippet is set to NaN.</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Further arguments passed on to psd().</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>freqs</code></strong> :&ensp;<code>array</code> of <code>floats</code></dt>
<dd>For each data snippet the frequency of the maximum power.</dd>
</dl></div>
</dd>
<dt id="thunderlab.powerspectrum.add_spectrum_config"><code class="name flex">
<span>def <span class="ident">add_spectrum_config</span></span>(<span>cfg, freq_resolution=1.0, overlap_frac=0.5, detrend='constant', window='hann')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_spectrum_config(cfg, freq_resolution=1.0, overlap_frac=0.5,
                        detrend=&#39;constant&#39;, window=&#39;hann&#39;):
    &#34;&#34;&#34;Add all parameters needed for the psd() and spectrogram() functions as a new section to a configuration.

    Parameters
    ----------
    cfg: ConfigFile
        The configuration.
        
    See psd() and spectrogram() for details on the remaining arguments.
    &#34;&#34;&#34;
    cfg.add_section(&#39;Power spectra and spectrograms:&#39;)
    cfg.add(&#39;frequencyResolution&#39;, freq_resolution, &#39;Hz&#39;, &#39;Frequency resolution of power spectra and spectrograms.&#39;)
    cfg.add(&#39;overlapFraction&#39;, 100*overlap_frac, &#39;%&#39;, &#39;Overlap of subsequent data segments in power spectra and spectrograms.&#39;)
    cfg.add(&#39;detrendMethod&#39;, detrend, &#39;&#39;, &#39;Detrend method to be applied on data segments for computing power spectra and spectrograms (&#34;constant&#34;, &#34;linear&#34;, or &#34;none&#34;.&#39;)
    cfg.add(&#39;windowFunction&#39;, window, &#39;&#39;, &#39;Window function applied on data segements for computing power spectra and spectrograms (one of &#34;hann&#34;, &#34;blackman&#34;, &#34;hamming&#34;, &#34;bartlett&#34;, &#34;boxcar&#34;, &#34;triang&#34;, &#34;parzen&#34;, &#34;bohman&#34;, &#34;blackmanharris&#34;, &#34;nuttall&#34;, &#34;fattop&#34;, &#34;barthann&#34;).&#39;)</code></pre>
</details>
<div class="desc"><p>Add all parameters needed for the psd() and spectrogram() functions as a new section to a configuration.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cfg</code></strong> :&ensp;<code>ConfigFile</code></dt>
<dd>The configuration.</dd>
</dl>
<p>See psd() and spectrogram() for details on the remaining arguments.</p></div>
</dd>
<dt id="thunderlab.powerspectrum.spectrum_args"><code class="name flex">
<span>def <span class="ident">spectrum_args</span></span>(<span>cfg)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spectrum_args(cfg):
    &#34;&#34;&#34;Translates a configuration to the respective parameter names of the psd() and spectrogram() functions.
    
    The return value can then be passed as key-word arguments to
    these functions.

    Parameters
    ----------
    cfg: ConfigFile
        The configuration.

    Returns
    -------
    a: dict
        Dictionary with names of arguments of the psd() and spectrogram()
        functions and their values as supplied by `cfg`.
    &#34;&#34;&#34;
    a = cfg.map(freq_resolution=&#39;frequencyResolution&#39;,
                overlap_frac=&#39;overlapFraction&#39;,
                detrend=&#39;detrendMethod&#39;,
                window=&#39;windowFunction&#39;)
    a[&#39;overlap_frac&#39;] *= 0.01
    return a</code></pre>
</details>
<div class="desc"><p>Translates a configuration to the respective parameter names of the psd() and spectrogram() functions.</p>
<p>The return value can then be passed as key-word arguments to
these functions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cfg</code></strong> :&ensp;<code>ConfigFile</code></dt>
<dd>The configuration.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>a</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with names of arguments of the psd() and spectrogram()
functions and their values as supplied by <code>cfg</code>.</dd>
</dl></div>
</dd>
<dt id="thunderlab.powerspectrum.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    import matplotlib.pyplot as plt
    print(&#39;Compute powerspectra of two sine waves (300 and 450 Hz)&#39;)

    # generate data:
    fundamentals = [300, 450]  # Hz
    rate = 100_000.0      # Hz
    time = np.arange(0.0, 8.0, 1.0/rate)
    data = np.sin(2*np.pi*fundamentals[0]*time) + 0.5*np.sin(2*np.pi*fundamentals[1]*time)

    # compute power spectrum:
    freqs, power = psd(data, rate, freq_resolution=0.5,
                       detrend=&#39;none&#39;, window=&#39;hann&#39;)
    df = np.mean(np.diff(freqs))
    nfft = int(rate/df)

    # plot power spectrum:
    fig, (ax1, ax2) = plt.subplots(1, 2, layout=&#39;constrained&#39;)
    plot_decibel_psd(ax1, freqs, power,
                     sstyle=dict(lw=2,
                                 label=f&#39;$\\Delta f={df:.1f}$Hz, nnft={nfft}&#39;))
    ax1.legend(loc=&#39;upper left&#39;)

    # compute spectrogram:
    freqs, times, power = spectrogram(data, rate, freq_resolution=2)
    df = np.mean(np.diff(freqs))
    dt = 1/df
    # plot spectrogram:
    ax2.pcolormesh(times, freqs, decibel(power, min_power=1e-40),
                   vmin=-100, shading=&#39;nearest&#39;)
    ax2.text(0.05, 0.98, f&#39;$\\Delta f={df:.2f}$Hz, $\\Delta t={dt:.2f}$s&#39;,
             transform=ax2.transAxes, va=&#39;top&#39;,
             bbox=dict(boxstyle=&#39;round&#39;, facecolor=&#39;white&#39;))
    ax2.set_xlim(time[0], time[-1] + time[1])
    ax2.set_ylim(0, 600)
    ax2.set_xlabel(&#39;Time [s]&#39;)
    ax2.set_ylabel(&#39;Frequency [Hz]&#39;)
    
    plt.show()</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul>
<li><a href="#computation-of-nfft">Computation of nfft</a></li>
<li><a href="#decibel">Decibel</a></li>
<li><a href="#power-spectra">Power spectra</a></li>
<li><a href="#power-spectrum-analysis">Power spectrum analysis</a></li>
<li><a href="#visualization">Visualization</a></li>
<li><a href="#configuration-parameter">Configuration parameter</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="thunderlab" href="index.html">thunderlab</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="thunderlab.powerspectrum.next_power_of_two" href="#thunderlab.powerspectrum.next_power_of_two">next_power_of_two</a></code></li>
<li><code><a title="thunderlab.powerspectrum.nfft" href="#thunderlab.powerspectrum.nfft">nfft</a></code></li>
<li><code><a title="thunderlab.powerspectrum.decibel" href="#thunderlab.powerspectrum.decibel">decibel</a></code></li>
<li><code><a title="thunderlab.powerspectrum.power" href="#thunderlab.powerspectrum.power">power</a></code></li>
<li><code><a title="thunderlab.powerspectrum.psd" href="#thunderlab.powerspectrum.psd">psd</a></code></li>
<li><code><a title="thunderlab.powerspectrum.spectrogram" href="#thunderlab.powerspectrum.spectrogram">spectrogram</a></code></li>
<li><code><a title="thunderlab.powerspectrum.plot_decibel_psd" href="#thunderlab.powerspectrum.plot_decibel_psd">plot_decibel_psd</a></code></li>
<li><code><a title="thunderlab.powerspectrum.peak_freqs" href="#thunderlab.powerspectrum.peak_freqs">peak_freqs</a></code></li>
<li><code><a title="thunderlab.powerspectrum.add_spectrum_config" href="#thunderlab.powerspectrum.add_spectrum_config">add_spectrum_config</a></code></li>
<li><code><a title="thunderlab.powerspectrum.spectrum_args" href="#thunderlab.powerspectrum.spectrum_args">spectrum_args</a></code></li>
<li><code><a title="thunderlab.powerspectrum.main" href="#thunderlab.powerspectrum.main">main</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
